# 08. よく使う機能の実装例

WPF アプリケーションでよく実装する機能を Tauri で実現する方法を具体例で説明します。実際のビジネスアプリケーションで使える実装パターンを紹介します。

## 1. ファイルダイアログ（OpenFileDialog/SaveFileDialog）

### WPF 版（参考）

```csharp
private void OpenFile_Click(object sender, RoutedEventArgs e)
{
    var dialog = new OpenFileDialog
    {
        Filter = "テキストファイル (*.txt)|*.txt|すべてのファイル (*.*)|*.*"
    };

    if (dialog.ShowDialog() == true)
    {
        var content = File.ReadAllText(dialog.FileName);
        ContentTextBox.Text = content;
    }
}
```

### Tauri 版

**Rust 側（src-tauri/Cargo.toml に依存追加）**

```toml
[dependencies]
tauri = { version = "2", features = ["dialog-open", "dialog-save", "fs-read-file", "fs-write-file"] }
```

**TypeScript 側**

```typescript
import { open, save } from "@tauri-apps/plugin-dialog";
import { readTextFile, writeTextFile } from "@tauri-apps/plugin-fs";

class FileDialogManager {
    async openTextFile(): Promise<string | null> {
        try {
            // ファイル選択ダイアログを表示
            const filePath = await open({
                title: "テキストファイルを開く",
                filters: [
                    {
                        name: "テキストファイル",
                        extensions: ["txt", "md", "json"],
                    },
                    {
                        name: "すべてのファイル",
                        extensions: ["*"],
                    },
                ],
            });

            if (filePath) {
                // ファイルの内容を読み込み
                const content = await readTextFile(filePath);
                return content;
            }

            return null;
        } catch (error) {
            console.error("ファイル読み込みエラー:", error);
            throw new Error(`ファイルを開けませんでした: ${error}`);
        }
    }

    async saveTextFile(
        content: string,
        defaultPath?: string
    ): Promise<boolean> {
        try {
            // ファイル保存ダイアログを表示
            const filePath = await save({
                title: "ファイルを保存",
                defaultPath: defaultPath || "document.txt",
                filters: [
                    {
                        name: "テキストファイル",
                        extensions: ["txt"],
                    },
                ],
            });

            if (filePath) {
                // ファイルに保存
                await writeTextFile(filePath, content);
                return true;
            }

            return false;
        } catch (error) {
            console.error("ファイル保存エラー:", error);
            throw new Error(`ファイルを保存できませんでした: ${error}`);
        }
    }
}

// 使用例
const fileManager = new FileDialogManager();

document.getElementById("open-file")?.addEventListener("click", async () => {
    try {
        const content = await fileManager.openTextFile();
        if (content !== null) {
            const textarea = document.getElementById(
                "editor"
            ) as HTMLTextAreaElement;
            textarea.value = content;
        }
    } catch (error) {
        alert(error);
    }
});

document.getElementById("save-file")?.addEventListener("click", async () => {
    try {
        const textarea = document.getElementById(
            "editor"
        ) as HTMLTextAreaElement;
        const saved = await fileManager.saveTextFile(textarea.value);
        if (saved) {
            alert("ファイルを保存しました");
        }
    } catch (error) {
        alert(error);
    }
});
```

## 2. アプリケーション設定の保存/読み込み

### 設定管理クラスの実装

**Rust 側**

```rust
use serde::{Deserialize, Serialize};
use std::fs;
use std::path::PathBuf;

#[derive(Serialize, Deserialize, Clone)]
pub struct AppSettings {
    pub window_width: u32,
    pub window_height: u32,
    pub theme: String,
    pub auto_save: bool,
    pub recent_files: Vec<String>,
    pub font_size: u32,
}

impl Default for AppSettings {
    fn default() -> Self {
        Self {
            window_width: 800,
            window_height: 600,
            theme: "light".to_string(),
            auto_save: true,
            recent_files: Vec::new(),
            font_size: 14,
        }
    }
}

#[tauri::command]
async fn load_settings() -> Result<AppSettings, String> {
    let settings_path = get_settings_path()?;

    if settings_path.exists() {
        let content = fs::read_to_string(&settings_path)
            .map_err(|e| format!("設定ファイル読み込みエラー: {}", e))?;

        serde_json::from_str(&content)
            .map_err(|e| format!("設定ファイル解析エラー: {}", e))
    } else {
        Ok(AppSettings::default())
    }
}

#[tauri::command]
async fn save_settings(settings: AppSettings) -> Result<(), String> {
    let settings_path = get_settings_path()?;

    // 設定ディレクトリを作成
    if let Some(parent) = settings_path.parent() {
        fs::create_dir_all(parent)
            .map_err(|e| format!("設定ディレクトリ作成エラー: {}", e))?;
    }

    let json = serde_json::to_string_pretty(&settings)
        .map_err(|e| format!("設定シリアライズエラー: {}", e))?;

    fs::write(&settings_path, json)
        .map_err(|e| format!("設定ファイル保存エラー: {}", e))
}

fn get_settings_path() -> Result<PathBuf, String> {
    let mut path = dirs::config_dir()
        .ok_or("設定ディレクトリが見つかりません")?;

    path.push("MyTauriApp");
    path.push("settings.json");

    Ok(path)
}

#[tauri::command]
async fn add_recent_file(file_path: String) -> Result<AppSettings, String> {
    let mut settings = load_settings().await?;

    // 既存のエントリを削除
    settings.recent_files.retain(|f| f != &file_path);

    // 先頭に追加
    settings.recent_files.insert(0, file_path);

    // 最大10件まで
    settings.recent_files.truncate(10);

    save_settings(settings.clone()).await?;
    Ok(settings)
}
```

**TypeScript 側**

```typescript
interface AppSettings {
    window_width: number;
    window_height: number;
    theme: string;
    auto_save: boolean;
    recent_files: string[];
    font_size: number;
}

class SettingsManager {
    private settings: AppSettings | null = null;

    async loadSettings(): Promise<AppSettings> {
        try {
            this.settings = await invoke<AppSettings>("load_settings");
            return this.settings;
        } catch (error) {
            console.error("設定読み込みエラー:", error);
            // デフォルト設定を返す
            this.settings = {
                window_width: 800,
                window_height: 600,
                theme: "light",
                auto_save: true,
                recent_files: [],
                font_size: 14,
            };
            return this.settings;
        }
    }

    async saveSettings(settings: AppSettings): Promise<void> {
        try {
            await invoke("save_settings", { settings });
            this.settings = settings;
        } catch (error) {
            console.error("設定保存エラー:", error);
            throw error;
        }
    }

    async addRecentFile(filePath: string): Promise<void> {
        try {
            this.settings = await invoke<AppSettings>("add_recent_file", {
                filePath,
            });
        } catch (error) {
            console.error("最近使用したファイル追加エラー:", error);
        }
    }

    getSettings(): AppSettings | null {
        return this.settings;
    }

    async updateTheme(theme: string): Promise<void> {
        if (this.settings) {
            this.settings.theme = theme;
            await this.saveSettings(this.settings);
            this.applyTheme(theme);
        }
    }

    async updateFontSize(fontSize: number): Promise<void> {
        if (this.settings) {
            this.settings.font_size = fontSize;
            await this.saveSettings(this.settings);
            this.applyFontSize(fontSize);
        }
    }

    private applyTheme(theme: string): void {
        document.body.className = `theme-${theme}`;
    }

    private applyFontSize(fontSize: number): void {
        document.documentElement.style.setProperty(
            "--font-size",
            `${fontSize}px`
        );
    }

    async applyAllSettings(): Promise<void> {
        if (!this.settings) {
            await this.loadSettings();
        }

        if (this.settings) {
            this.applyTheme(this.settings.theme);
            this.applyFontSize(this.settings.font_size);
            this.updateRecentFilesMenu();
        }
    }

    private updateRecentFilesMenu(): void {
        const menu = document.getElementById("recent-files-menu");
        if (menu && this.settings) {
            menu.innerHTML = "";

            this.settings.recent_files.forEach((file) => {
                const item = document.createElement("button");
                item.textContent = file.split("/").pop() || file;
                item.title = file;
                item.addEventListener("click", () => this.openRecentFile(file));
                menu.appendChild(item);
            });
        }
    }

    private async openRecentFile(filePath: string): Promise<void> {
        // ファイルを開く処理
        console.log("最近使用したファイルを開く:", filePath);
    }
}

// 使用例
const settingsManager = new SettingsManager();

// アプリケーション起動時
document.addEventListener("DOMContentLoaded", async () => {
    await settingsManager.applyAllSettings();

    // 設定画面のイベントハンドラー
    document
        .getElementById("theme-select")
        ?.addEventListener("change", async (e) => {
            const theme = (e.target as HTMLSelectElement).value;
            await settingsManager.updateTheme(theme);
        });

    document
        .getElementById("font-size-input")
        ?.addEventListener("change", async (e) => {
            const fontSize = parseInt((e.target as HTMLInputElement).value);
            await settingsManager.updateFontSize(fontSize);
        });
});
```

## 3. データベース操作（SQLite）

**Rust 側（Cargo.toml に依存追加）**

```toml
[dependencies]
rusqlite = { version = "0.29", features = ["bundled"] }
tokio = { version = "1", features = ["full"] }
```

```rust
use rusqlite::{Connection, Result};
use serde::{Deserialize, Serialize};
use std::sync::Mutex;

#[derive(Serialize, Deserialize, Clone)]
pub struct Customer {
    pub id: Option<i64>,
    pub name: String,
    pub email: String,
    pub phone: String,
    pub created_at: String,
}

pub struct Database {
    conn: Mutex<Connection>,
}

impl Database {
    pub fn new(db_path: &str) -> Result<Self> {
        let conn = Connection::open(db_path)?;

        // テーブル作成
        conn.execute(
            "CREATE TABLE IF NOT EXISTS customers (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                name TEXT NOT NULL,
                email TEXT UNIQUE NOT NULL,
                phone TEXT,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP
            )",
            [],
        )?;

        Ok(Database {
            conn: Mutex::new(conn),
        })
    }
}

// グローバル変数として保持
static mut DB: Option<Database> = None;

#[tauri::command]
async fn init_database() -> Result<(), String> {
    unsafe {
        let db_path = "customers.db";
        let database = Database::new(db_path)
            .map_err(|e| format!("データベース初期化エラー: {}", e))?;
        DB = Some(database);
    }
    Ok(())
}

#[tauri::command]
async fn add_customer(customer: Customer) -> Result<Customer, String> {
    unsafe {
        if let Some(db) = &DB {
            let conn = db.conn.lock().unwrap();

            conn.execute(
                "INSERT INTO customers (name, email, phone) VALUES (?1, ?2, ?3)",
                [&customer.name, &customer.email, &customer.phone],
            ).map_err(|e| format!("顧客追加エラー: {}", e))?;

            let id = conn.last_insert_rowid();

            let mut stmt = conn.prepare(
                "SELECT id, name, email, phone, created_at FROM customers WHERE id = ?1"
            ).map_err(|e| e.to_string())?;

            let customer_row = stmt.query_row([id], |row| {
                Ok(Customer {
                    id: Some(row.get(0)?),
                    name: row.get(1)?,
                    email: row.get(2)?,
                    phone: row.get(3)?,
                    created_at: row.get(4)?,
                })
            }).map_err(|e| e.to_string())?;

            Ok(customer_row)
        } else {
            Err("データベースが初期化されていません".to_string())
        }
    }
}

#[tauri::command]
async fn get_customers() -> Result<Vec<Customer>, String> {
    unsafe {
        if let Some(db) = &DB {
            let conn = db.conn.lock().unwrap();

            let mut stmt = conn.prepare(
                "SELECT id, name, email, phone, created_at FROM customers ORDER BY created_at DESC"
            ).map_err(|e| e.to_string())?;

            let customers = stmt.query_map([], |row| {
                Ok(Customer {
                    id: Some(row.get(0)?),
                    name: row.get(1)?,
                    email: row.get(2)?,
                    phone: row.get(3)?,
                    created_at: row.get(4)?,
                })
            }).map_err(|e| e.to_string())?
            .collect::<Result<Vec<_>, _>>()
            .map_err(|e| e.to_string())?;

            Ok(customers)
        } else {
            Err("データベースが初期化されていません".to_string())
        }
    }
}

#[tauri::command]
async fn update_customer(customer: Customer) -> Result<(), String> {
    unsafe {
        if let Some(db) = &DB {
            let conn = db.conn.lock().unwrap();

            let rows_affected = conn.execute(
                "UPDATE customers SET name = ?1, email = ?2, phone = ?3 WHERE id = ?4",
                [&customer.name, &customer.email, &customer.phone, &customer.id.unwrap().to_string()],
            ).map_err(|e| format!("顧客更新エラー: {}", e))?;

            if rows_affected == 0 {
                return Err("更新対象の顧客が見つかりません".to_string());
            }

            Ok(())
        } else {
            Err("データベースが初期化されていません".to_string())
        }
    }
}

#[tauri::command]
async fn delete_customer(id: i64) -> Result<(), String> {
    unsafe {
        if let Some(db) = &DB {
            let conn = db.conn.lock().unwrap();

            let rows_affected = conn.execute(
                "DELETE FROM customers WHERE id = ?1",
                [id],
            ).map_err(|e| format!("顧客削除エラー: {}", e))?;

            if rows_affected == 0 {
                return Err("削除対象の顧客が見つかりません".to_string());
            }

            Ok(())
        } else {
            Err("データベースが初期化されていません".to_string())
        }
    }
}
```

**TypeScript 側**

```typescript
interface Customer {
    id?: number;
    name: string;
    email: string;
    phone: string;
    created_at?: string;
}

class CustomerManager {
    private customers: Customer[] = [];

    async initialize(): Promise<void> {
        try {
            await invoke("init_database");
            await this.loadCustomers();
        } catch (error) {
            console.error("データベース初期化エラー:", error);
            throw error;
        }
    }

    async loadCustomers(): Promise<Customer[]> {
        try {
            this.customers = await invoke<Customer[]>("get_customers");
            this.updateCustomerTable();
            return this.customers;
        } catch (error) {
            console.error("顧客一覧取得エラー:", error);
            throw error;
        }
    }

    async addCustomer(
        customer: Omit<Customer, "id" | "created_at">
    ): Promise<Customer> {
        try {
            const newCustomer = await invoke<Customer>("add_customer", {
                customer,
            });
            this.customers.unshift(newCustomer);
            this.updateCustomerTable();
            return newCustomer;
        } catch (error) {
            console.error("顧客追加エラー:", error);
            throw error;
        }
    }

    async updateCustomer(customer: Customer): Promise<void> {
        try {
            await invoke("update_customer", { customer });
            const index = this.customers.findIndex((c) => c.id === customer.id);
            if (index !== -1) {
                this.customers[index] = customer;
                this.updateCustomerTable();
            }
        } catch (error) {
            console.error("顧客更新エラー:", error);
            throw error;
        }
    }

    async deleteCustomer(id: number): Promise<void> {
        try {
            await invoke("delete_customer", { id });
            this.customers = this.customers.filter((c) => c.id !== id);
            this.updateCustomerTable();
        } catch (error) {
            console.error("顧客削除エラー:", error);
            throw error;
        }
    }

    private updateCustomerTable(): void {
        const tableBody = document.getElementById(
            "customer-table-body"
        ) as HTMLTableSectionElement;
        tableBody.innerHTML = "";

        this.customers.forEach((customer) => {
            const row = document.createElement("tr");
            row.innerHTML = `
                <td>${customer.name}</td>
                <td>${customer.email}</td>
                <td>${customer.phone}</td>
                <td>${customer.created_at}</td>
                <td>
                    <button onclick="editCustomer(${customer.id})" class="btn btn-edit">編集</button>
                    <button onclick="deleteCustomer(${customer.id})" class="btn btn-delete">削除</button>
                </td>
            `;
            tableBody.appendChild(row);
        });
    }

    getCustomer(id: number): Customer | undefined {
        return this.customers.find((c) => c.id === id);
    }
}

// グローバルインスタンス
const customerManager = new CustomerManager();

// アプリケーション初期化
document.addEventListener("DOMContentLoaded", async () => {
    try {
        await customerManager.initialize();
        setupCustomerForm();
    } catch (error) {
        alert(`初期化エラー: ${error}`);
    }
});

function setupCustomerForm(): void {
    const form = document.getElementById("customer-form") as HTMLFormElement;
    form.addEventListener("submit", async (e) => {
        e.preventDefault();

        const formData = new FormData(form);
        const customer = {
            name: formData.get("name") as string,
            email: formData.get("email") as string,
            phone: formData.get("phone") as string,
        };

        try {
            await customerManager.addCustomer(customer);
            form.reset();
            alert("顧客を追加しました");
        } catch (error) {
            alert(`追加エラー: ${error}`);
        }
    });
}

// グローバル関数（HTMLから呼び出し用）
async function editCustomer(id: number): Promise<void> {
    const customer = customerManager.getCustomer(id);
    if (customer) {
        // 編集フォームに値を設定
        (document.getElementById("edit-name") as HTMLInputElement).value =
            customer.name;
        (document.getElementById("edit-email") as HTMLInputElement).value =
            customer.email;
        (document.getElementById("edit-phone") as HTMLInputElement).value =
            customer.phone;

        // 編集ダイアログを表示
        document.getElementById("edit-dialog")!.style.display = "block";

        // 保存ボタンのイベントハンドラー
        const saveBtn = document.getElementById("save-edit");
        saveBtn!.onclick = async () => {
            const updatedCustomer: Customer = {
                id: customer.id,
                name: (document.getElementById("edit-name") as HTMLInputElement)
                    .value,
                email: (
                    document.getElementById("edit-email") as HTMLInputElement
                ).value,
                phone: (
                    document.getElementById("edit-phone") as HTMLInputElement
                ).value,
            };

            try {
                await customerManager.updateCustomer(updatedCustomer);
                document.getElementById("edit-dialog")!.style.display = "none";
                alert("顧客情報を更新しました");
            } catch (error) {
                alert(`更新エラー: ${error}`);
            }
        };
    }
}

async function deleteCustomer(id: number): Promise<void> {
    if (confirm("この顧客を削除しますか？")) {
        try {
            await customerManager.deleteCustomer(id);
            alert("顧客を削除しました");
        } catch (error) {
            alert(`削除エラー: ${error}`);
        }
    }
}
```

## 4. ウィンドウ管理

```typescript
import { getCurrentWindow } from "@tauri-apps/api/window";

class WindowManager {
    private window = getCurrentWindow();

    async minimizeWindow(): Promise<void> {
        await this.window.minimize();
    }

    async maximizeWindow(): Promise<void> {
        await this.window.maximize();
    }

    async closeWindow(): Promise<void> {
        await this.window.close();
    }

    async setWindowTitle(title: string): Promise<void> {
        await this.window.setTitle(title);
    }

    async setWindowSize(width: number, height: number): Promise<void> {
        await this.window.setSize({ width, height });
    }

    async centerWindow(): Promise<void> {
        await this.window.center();
    }

    async setAlwaysOnTop(alwaysOnTop: boolean): Promise<void> {
        await this.window.setAlwaysOnTop(alwaysOnTop);
    }
}

// 使用例
const windowManager = new WindowManager();

document.getElementById("minimize")?.addEventListener("click", () => {
    windowManager.minimizeWindow();
});

document.getElementById("maximize")?.addEventListener("click", () => {
    windowManager.maximizeWindow();
});

document.getElementById("close")?.addEventListener("click", () => {
    windowManager.closeWindow();
});
```

## 次のステップ

よく使う機能の実装パターンを理解したら、[09\_エラーハンドリングとデバッグ.md](./09_エラーハンドリングとデバッグ.md) でエラー処理とデバッグ技術を学習しましょう。
