# 11. パフォーマンスとセキュリティ

WPF アプリケーションのパフォーマンス最適化とセキュリティ対策に相当する、Tauri アプリケーションでの実装手法を解説します。

## 1. パフォーマンス最適化

### フロントエンド最適化

**1. バンドルサイズの最適化**

`vite.config.ts`

```typescript
import { defineConfig } from "vite";
import { resolve } from "path";

export default defineConfig({
    build: {
        // チャンク分割によるコード分離
        rollupOptions: {
            output: {
                manualChunks: {
                    vendor: ["@tauri-apps/api"],
                    utils: ["./src/utils/index.ts"],
                    components: ["./src/components/index.ts"],
                },
            },
        },
        // 最小化とgzip圧縮
        minify: "terser",
        terserOptions: {
            compress: {
                drop_console: true, // 本番環境でconsole.logを削除
                drop_debugger: true,
            },
        },
        // ソースマップを本番では無効化
        sourcemap: process.env.NODE_ENV === "development",
    },
    // プリロード最適化
    optimizeDeps: {
        include: ["@tauri-apps/api/core", "@tauri-apps/api/fs"],
    },
});
```

**2. レンダリング最適化**

```typescript
// Virtual Scrolling の実装例
class VirtualList {
    private container: HTMLElement;
    private itemHeight: number;
    private items: any[];
    private visibleCount: number;
    private scrollTop = 0;

    constructor(container: HTMLElement, itemHeight: number) {
        this.container = container;
        this.itemHeight = itemHeight;
        this.visibleCount = Math.ceil(container.clientHeight / itemHeight) + 2;

        container.addEventListener("scroll", this.onScroll.bind(this));
    }

    setItems(items: any[]): void {
        this.items = items;
        this.render();
    }

    private onScroll(): void {
        this.scrollTop = this.container.scrollTop;
        this.render();
    }

    private render(): void {
        const startIndex = Math.floor(this.scrollTop / this.itemHeight);
        const endIndex = Math.min(
            startIndex + this.visibleCount,
            this.items.length
        );

        // 実際に表示する範囲のアイテムのみ生成
        const visibleItems = this.items.slice(startIndex, endIndex);

        this.container.innerHTML = `
            <div style="height: ${startIndex * this.itemHeight}px;"></div>
            ${visibleItems
                .map((item, index) => this.renderItem(item, startIndex + index))
                .join("")}
            <div style="height: ${
                (this.items.length - endIndex) * this.itemHeight
            }px;"></div>
        `;
    }

    private renderItem(item: any, index: number): string {
        return `<div class="list-item" data-index="${index}">${item.name}</div>`;
    }
}

// 使用例
const listContainer = document.getElementById("data-list") as HTMLElement;
const virtualList = new VirtualList(listContainer, 50); // 各アイテムの高さは50px

// 大量データの表示
async function loadLargeDataset(): Promise<void> {
    try {
        const data = await invoke<any[]>("get_large_dataset");
        virtualList.setItems(data);
    } catch (error) {
        console.error("データ読み込み失敗:", error);
    }
}
```

**3. メモリ管理とガベージコレクション**

```typescript
class MemoryManager {
    private static cache = new Map<string, any>();
    private static readonly MAX_CACHE_SIZE = 100;

    // LRUキャッシュの実装
    static setCache(key: string, value: any): void {
        if (this.cache.size >= this.MAX_CACHE_SIZE) {
            const firstKey = this.cache.keys().next().value;
            this.cache.delete(firstKey);
        }

        this.cache.delete(key); // 既存のエントリを削除
        this.cache.set(key, value); // 最新として追加
    }

    static getCache(key: string): any {
        if (this.cache.has(key)) {
            const value = this.cache.get(key);
            this.cache.delete(key);
            this.cache.set(key, value); // LRU: 最新として移動
            return value;
        }
        return null;
    }

    static clearCache(): void {
        this.cache.clear();
    }

    // 未使用リソースのクリーンアップ
    static cleanup(): void {
        // イベントリスナーの削除
        document.querySelectorAll("[data-cleanup]").forEach((element) => {
            const events =
                element.getAttribute("data-cleanup")?.split(",") || [];
            events.forEach((event) => {
                element.removeEventListener(event.trim(), () => {});
            });
        });

        // キャッシュクリア
        this.clearCache();

        // 手動でガベージコレクションを促す（開発時のみ）
        if (import.meta.env.DEV && "gc" in window) {
            (window as any).gc();
        }
    }
}

// ページ遷移時のクリーンアップ
window.addEventListener("beforeunload", () => {
    MemoryManager.cleanup();
});
```

### バックエンド最適化

**1. Rust 側の非同期処理最適化**

```rust
use tokio::sync::Semaphore;
use std::sync::Arc;
use std::collections::HashMap;
use tokio::time::{Duration, timeout};

// 並行処理の制限
static CONCURRENT_OPERATIONS: Semaphore = Semaphore::const_new(5);

#[tauri::command]
async fn process_large_file(file_path: String) -> Result<String, String> {
    let _permit = CONCURRENT_OPERATIONS.acquire().await
        .map_err(|e| format!("並行処理制限エラー: {}", e))?;

    // タイムアウト付きで処理実行
    timeout(Duration::from_secs(30), async {
        let content = tokio::fs::read_to_string(&file_path).await
            .map_err(|e| format!("ファイル読み込み失敗: {}", e))?;

        // 重い処理をブロッキングスレッドで実行
        let processed = tokio::task::spawn_blocking(move || {
            expensive_processing(content)
        }).await
        .map_err(|e| format!("処理実行失敗: {}", e))?;

        Ok(processed)
    }).await
    .map_err(|_| "処理がタイムアウトしました".to_string())?
}

fn expensive_processing(content: String) -> String {
    // CPUを多用する処理をここで実行
    content.lines()
        .map(|line| line.trim().to_uppercase())
        .collect::<Vec<String>>()
        .join("\n")
}

// キャッシュ機能付きのデータ取得
use std::sync::Mutex;
use std::time::{SystemTime, UNIX_EPOCH};

struct CacheEntry {
    data: String,
    timestamp: u64,
}

type Cache = Arc<Mutex<HashMap<String, CacheEntry>>>;

#[tauri::command]
async fn get_cached_data(
    key: String,
    cache: tauri::State<'_, Cache>
) -> Result<String, String> {
    const CACHE_DURATION: u64 = 300; // 5分

    let now = SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .unwrap()
        .as_secs();

    // キャッシュから確認
    {
        let cache_guard = cache.lock().unwrap();
        if let Some(entry) = cache_guard.get(&key) {
            if now - entry.timestamp < CACHE_DURATION {
                return Ok(entry.data.clone());
            }
        }
    }

    // キャッシュにないか期限切れの場合、新しいデータを取得
    let new_data = fetch_data_from_source(&key).await?;

    // キャッシュに保存
    {
        let mut cache_guard = cache.lock().unwrap();
        cache_guard.insert(key, CacheEntry {
            data: new_data.clone(),
            timestamp: now,
        });
    }

    Ok(new_data)
}

async fn fetch_data_from_source(key: &str) -> Result<String, String> {
    // データソースからの実際の取得処理
    tokio::time::sleep(Duration::from_millis(100)).await; // 模擬的な遅延
    Ok(format!("Data for key: {}", key))
}

// メイン関数でキャッシュを初期化
#[cfg_attr(mobile, tauri::mobile_entry_point)]
pub fn run() {
    let cache: Cache = Arc::new(Mutex::new(HashMap::new()));

    tauri::Builder::default()
        .manage(cache)
        .invoke_handler(tauri::generate_handler![
            process_large_file,
            get_cached_data
        ])
        .run(tauri::generate_context!())
        .expect("error while running tauri application");
}
```

**2. データベース最適化**

```rust
use sqlx::{SqlitePool, Row};
use std::sync::Arc;

pub struct DatabaseManager {
    pool: SqlitePool,
}

impl DatabaseManager {
    pub async fn new(database_url: &str) -> Result<Self, sqlx::Error> {
        let pool = SqlitePool::connect_with(
            database_url.parse().unwrap()
        ).await?;

        // 接続プールの設定
        pool.set_max_connections(10).await;

        // インデックスの作成
        sqlx::query("CREATE INDEX IF NOT EXISTS idx_users_email ON users(email)")
            .execute(&pool)
            .await?;

        sqlx::query("CREATE INDEX IF NOT EXISTS idx_orders_user_id ON orders(user_id)")
            .execute(&pool)
            .await?;

        Ok(Self { pool })
    }

    // バッチ処理でのデータ挿入
    pub async fn batch_insert_users(&self, users: Vec<(String, String)>) -> Result<(), sqlx::Error> {
        let mut tx = self.pool.begin().await?;

        for chunk in users.chunks(100) { // 100件ずつバッチ処理
            let mut query_builder = sqlx::QueryBuilder::new(
                "INSERT INTO users (name, email) "
            );

            query_builder.push_values(chunk, |mut b, (name, email)| {
                b.push_bind(name).push_bind(email);
            });

            query_builder.build().execute(&mut *tx).await?;
        }

        tx.commit().await?;
        Ok(())
    }

    // ページネーション付きクエリ
    pub async fn get_users_paginated(
        &self,
        page: i32,
        per_page: i32
    ) -> Result<Vec<(i32, String, String)>, sqlx::Error> {
        let offset = (page - 1) * per_page;

        let rows = sqlx::query(
            "SELECT id, name, email FROM users
             ORDER BY id
             LIMIT ? OFFSET ?"
        )
        .bind(per_page)
        .bind(offset)
        .fetch_all(&self.pool)
        .await?;

        let users = rows.into_iter()
            .map(|row| (
                row.get::<i32, _>("id"),
                row.get::<String, _>("name"),
                row.get::<String, _>("email")
            ))
            .collect();

        Ok(users)
    }
}

#[tauri::command]
async fn get_users_with_pagination(
    page: i32,
    per_page: i32,
    db: tauri::State<'_, Arc<DatabaseManager>>
) -> Result<Vec<(i32, String, String)>, String> {
    db.get_users_paginated(page, per_page)
        .await
        .map_err(|e| e.to_string())
}
```

## 2. セキュリティ対策

### 入力値検証とサニタイゼーション

**1. フロントエンド側の検証**

```typescript
class InputValidator {
    static sanitizeHtml(input: string): string {
        const div = document.createElement("div");
        div.textContent = input;
        return div.innerHTML;
    }

    static validateEmail(email: string): boolean {
        const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
        return emailRegex.test(email) && email.length <= 254;
    }

    static validateFilePath(path: string): boolean {
        // 危険なパスパターンをチェック
        const dangerousPatterns = [
            /\.\./, // ディレクトリトラバーサル
            /[<>:"|?*]/, // 無効な文字
            /^\/\w+/, // ルートパスの直接指定
            /system32/i, // システムディレクトリ
            /\/etc\//, // Unix系システムディレクトリ
        ];

        return !dangerousPatterns.some((pattern) => pattern.test(path));
    }

    static validateJsonInput(input: string): { isValid: boolean; data?: any } {
        try {
            const data = JSON.parse(input);

            // JSONの深度制限
            if (this.getObjectDepth(data) > 10) {
                return { isValid: false };
            }

            // JSONのサイズ制限
            if (JSON.stringify(data).length > 1_000_000) {
                return { isValid: false };
            }

            return { isValid: true, data };
        } catch {
            return { isValid: false };
        }
    }

    private static getObjectDepth(obj: any, depth = 0): number {
        if (typeof obj !== "object" || obj === null) {
            return depth;
        }

        const depths = Object.values(obj).map((value) =>
            this.getObjectDepth(value, depth + 1)
        );

        return Math.max(...depths);
    }

    static createSecureForm(containerId: string): HTMLFormElement {
        const container = document.getElementById(containerId);
        if (!container) throw new Error("Container not found");

        const form = document.createElement("form");
        form.setAttribute("autocomplete", "off");
        form.setAttribute("novalidate", "true");

        // CSRF対策のトークン
        const csrfToken = this.generateCSRFToken();
        const csrfInput = document.createElement("input");
        csrfInput.type = "hidden";
        csrfInput.name = "csrf_token";
        csrfInput.value = csrfToken;
        form.appendChild(csrfInput);

        container.appendChild(form);
        return form;
    }

    private static generateCSRFToken(): string {
        const array = new Uint8Array(32);
        crypto.getRandomValues(array);
        return Array.from(array, (byte) =>
            byte.toString(16).padStart(2, "0")
        ).join("");
    }
}

// 使用例
async function handleFileOperation(filePath: string): Promise<void> {
    // 入力値の検証
    if (!InputValidator.validateFilePath(filePath)) {
        throw new Error("無効なファイルパスです");
    }

    const sanitizedPath = InputValidator.sanitizeHtml(filePath);

    try {
        await invoke("safe_file_operation", { path: sanitizedPath });
    } catch (error) {
        console.error("ファイル操作失敗:", error);
        throw error;
    }
}
```

**2. Rust 側の検証とセキュリティ**

```rust
use regex::Regex;
use std::path::Path;
use serde::{Deserialize, Serialize};

#[derive(Deserialize)]
struct UserInput {
    name: String,
    email: String,
    file_path: Option<String>,
}

#[derive(Serialize)]
struct ValidationError {
    field: String,
    message: String,
}

#[derive(Serialize)]
struct ValidationResult {
    is_valid: bool,
    errors: Vec<ValidationError>,
}

fn validate_user_input(input: &UserInput) -> ValidationResult {
    let mut errors = Vec::new();

    // 名前の検証
    if input.name.is_empty() {
        errors.push(ValidationError {
            field: "name".to_string(),
            message: "名前は必須です".to_string(),
        });
    } else if input.name.len() > 100 {
        errors.push(ValidationError {
            field: "name".to_string(),
            message: "名前は100文字以下である必要があります".to_string(),
        });
    } else if contains_dangerous_characters(&input.name) {
        errors.push(ValidationError {
            field: "name".to_string(),
            message: "名前に無効な文字が含まれています".to_string(),
        });
    }

    // メールアドレスの検証
    if !is_valid_email(&input.email) {
        errors.push(ValidationError {
            field: "email".to_string(),
            message: "有効なメールアドレスを入力してください".to_string(),
        });
    }

    // ファイルパスの検証
    if let Some(ref path) = input.file_path {
        if !is_safe_file_path(path) {
            errors.push(ValidationError {
                field: "file_path".to_string(),
                message: "無効なファイルパスです".to_string(),
            });
        }
    }

    ValidationResult {
        is_valid: errors.is_empty(),
        errors,
    }
}

fn contains_dangerous_characters(input: &str) -> bool {
    let dangerous_chars = ['<', '>', '"', '\'', '&', '\0'];
    input.chars().any(|c| dangerous_chars.contains(&c))
}

fn is_valid_email(email: &str) -> bool {
    let email_regex = Regex::new(
        r"^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$"
    ).unwrap();

    email.len() <= 254 && email_regex.is_match(email)
}

fn is_safe_file_path(path: &str) -> bool {
    let path_obj = Path::new(path);

    // 相対パスでない場合は拒否
    if path_obj.is_absolute() {
        return false;
    }

    // ディレクトリトラバーサルの検出
    if path.contains("..") {
        return false;
    }

    // 危険なディレクトリパターン
    let dangerous_patterns = [
        "system32", "windows", "program files",
        "/etc/", "/bin/", "/usr/", "/var/",
    ];

    let path_lower = path.to_lowercase();
    if dangerous_patterns.iter().any(|&pattern| path_lower.contains(pattern)) {
        return false;
    }

    // 許可されたファイル拡張子のみ
    let allowed_extensions = ["txt", "json", "csv", "md"];
    if let Some(extension) = path_obj.extension() {
        if let Some(ext_str) = extension.to_str() {
            return allowed_extensions.contains(&ext_str.to_lowercase().as_str());
        }
    }

    false
}

#[tauri::command]
async fn secure_user_operation(input: UserInput) -> Result<String, ValidationResult> {
    let validation = validate_user_input(&input);

    if !validation.is_valid {
        return Err(validation);
    }

    // セキュアな処理を実行
    Ok("操作が正常に完了しました".to_string())
}

// SQLインジェクション対策
#[tauri::command]
async fn safe_database_query(
    user_id: i32,
    search_term: String,
    db: tauri::State<'_, sqlx::SqlitePool>
) -> Result<Vec<String>, String> {
    // プリペアドステートメントを使用
    let rows = sqlx::query_scalar::<_, String>(
        "SELECT title FROM documents
         WHERE user_id = ? AND title LIKE ?
         ORDER BY created_at DESC
         LIMIT 100"
    )
    .bind(user_id)
    .bind(format!("%{}%", search_term.replace('%', r"\%").replace('_', r"\_")))
    .fetch_all(&**db)
    .await
    .map_err(|e| e.to_string())?;

    Ok(rows)
}
```

### 機密データの保護

**1. 暗号化の実装**

```rust
use aes_gcm::{Aes256Gcm, Key, Nonce, aead::{Aead, NewAead}};
use base64::{encode, decode};
use rand::Rng;

pub struct EncryptionManager {
    cipher: Aes256Gcm,
}

impl EncryptionManager {
    pub fn new(key: &[u8; 32]) -> Self {
        let key = Key::from_slice(key);
        let cipher = Aes256Gcm::new(key);
        Self { cipher }
    }

    pub fn encrypt(&self, plaintext: &str) -> Result<String, String> {
        let mut rng = rand::thread_rng();
        let nonce_bytes: [u8; 12] = rng.gen();
        let nonce = Nonce::from_slice(&nonce_bytes);

        let ciphertext = self.cipher.encrypt(nonce, plaintext.as_bytes())
            .map_err(|e| format!("暗号化失敗: {}", e))?;

        // nonceとciphertextを結合してbase64エンコード
        let mut result = Vec::new();
        result.extend_from_slice(&nonce_bytes);
        result.extend_from_slice(&ciphertext);

        Ok(encode(result))
    }

    pub fn decrypt(&self, encrypted_data: &str) -> Result<String, String> {
        let data = decode(encrypted_data)
            .map_err(|e| format!("Base64デコード失敗: {}", e))?;

        if data.len() < 12 {
            return Err("データが短すぎます".to_string());
        }

        let (nonce_bytes, ciphertext) = data.split_at(12);
        let nonce = Nonce::from_slice(nonce_bytes);

        let plaintext = self.cipher.decrypt(nonce, ciphertext)
            .map_err(|e| format!("復号化失敗: {}", e))?;

        String::from_utf8(plaintext)
            .map_err(|e| format!("UTF-8変換失敗: {}", e))
    }
}

// 機密データストレージ
use tauri::api::path::app_local_data_dir;
use std::fs;

#[tauri::command]
async fn store_sensitive_data(
    app: tauri::AppHandle,
    key: String,
    value: String,
    encryption_manager: tauri::State<'_, EncryptionManager>
) -> Result<(), String> {
    let data_dir = app.path().app_local_data_dir()
        .map_err(|e| format!("データディレクトリ取得失敗: {}", e))?;

    fs::create_dir_all(&data_dir)
        .map_err(|e| format!("ディレクトリ作成失敗: {}", e))?;

    let encrypted_value = encryption_manager.encrypt(&value)?;
    let file_path = data_dir.join(format!("{}.enc", key));

    fs::write(file_path, encrypted_value)
        .map_err(|e| format!("ファイル書き込み失敗: {}", e))?;

    Ok(())
}

#[tauri::command]
async fn retrieve_sensitive_data(
    app: tauri::AppHandle,
    key: String,
    encryption_manager: tauri::State<'_, EncryptionManager>
) -> Result<String, String> {
    let data_dir = app.path().app_local_data_dir()
        .map_err(|e| format!("データディレクトリ取得失敗: {}", e))?;

    let file_path = data_dir.join(format!("{}.enc", key));

    if !file_path.exists() {
        return Err("データが見つかりません".to_string());
    }

    let encrypted_data = fs::read_to_string(file_path)
        .map_err(|e| format!("ファイル読み込み失敗: {}", e))?;

    encryption_manager.decrypt(&encrypted_data)
}

// 暗号化キーの生成と管理
fn generate_encryption_key() -> [u8; 32] {
    let mut rng = rand::thread_rng();
    let mut key = [0u8; 32];
    rng.fill(&mut key);
    key
}

fn get_or_create_encryption_key(app_handle: &tauri::AppHandle) -> Result<[u8; 32], String> {
    let data_dir = app_handle.path().app_local_data_dir()
        .map_err(|e| format!("データディレクトリ取得失敗: {}", e))?;

    let key_file = data_dir.join("encryption.key");

    if key_file.exists() {
        let key_data = fs::read(&key_file)
            .map_err(|e| format!("キーファイル読み込み失敗: {}", e))?;

        if key_data.len() != 32 {
            return Err("無効なキーファイル".to_string());
        }

        let mut key = [0u8; 32];
        key.copy_from_slice(&key_data);
        Ok(key)
    } else {
        fs::create_dir_all(&data_dir)
            .map_err(|e| format!("ディレクトリ作成失敗: {}", e))?;

        let key = generate_encryption_key();
        fs::write(&key_file, &key)
            .map_err(|e| format!("キーファイル書き込み失敗: {}", e))?;

        // Unix系OSではファイル権限を制限
        #[cfg(unix)]
        {
            use std::os::unix::fs::PermissionsExt;
            let mut perms = fs::metadata(&key_file).unwrap().permissions();
            perms.set_mode(0o600); // オーナーのみ読み書き可能
            fs::set_permissions(&key_file, perms).unwrap();
        }

        Ok(key)
    }
}
```

**2. 安全な通信**

```typescript
// 安全なAPI通信クラス
class SecureApiClient {
    private readonly baseUrl: string;
    private readonly timeout: number;

    constructor(baseUrl: string, timeout = 10000) {
        this.baseUrl = baseUrl;
        this.timeout = timeout;
    }

    async secureRequest<T>(
        endpoint: string,
        options: RequestInit = {}
    ): Promise<T> {
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), this.timeout);

        try {
            const response = await fetch(`${this.baseUrl}${endpoint}`, {
                ...options,
                signal: controller.signal,
                headers: {
                    "Content-Type": "application/json",
                    "X-Requested-With": "XMLHttpRequest",
                    ...options.headers,
                },
                credentials: "same-origin", // CSRF対策
            });

            clearTimeout(timeoutId);

            if (!response.ok) {
                throw new Error(
                    `HTTP ${response.status}: ${response.statusText}`
                );
            }

            // レスポンスサイズのチェック
            const contentLength = response.headers.get("content-length");
            if (contentLength && parseInt(contentLength) > 10_000_000) {
                throw new Error("レスポンスサイズが大きすぎます");
            }

            return await response.json();
        } catch (error) {
            clearTimeout(timeoutId);

            if (error instanceof Error && error.name === "AbortError") {
                throw new Error("リクエストがタイムアウトしました");
            }

            throw error;
        }
    }

    async uploadFile(file: File, endpoint: string): Promise<any> {
        // ファイルサイズとタイプの検証
        const maxSize = 10 * 1024 * 1024; // 10MB
        if (file.size > maxSize) {
            throw new Error("ファイルサイズが大きすぎます");
        }

        const allowedTypes = [
            "image/jpeg",
            "image/png",
            "text/plain",
            "application/pdf",
        ];
        if (!allowedTypes.includes(file.type)) {
            throw new Error("許可されていないファイル形式です");
        }

        const formData = new FormData();
        formData.append("file", file);

        return this.secureRequest(endpoint, {
            method: "POST",
            body: formData,
        });
    }
}
```

## 3. ログとセキュリティ監査

```rust
use log::{info, warn, error};
use chrono::{DateTime, Utc};
use serde::Serialize;

#[derive(Serialize)]
struct SecurityEvent {
    timestamp: DateTime<Utc>,
    event_type: String,
    severity: String,
    description: String,
    user_id: Option<String>,
    ip_address: Option<String>,
    additional_data: Option<serde_json::Value>,
}

pub struct SecurityLogger;

impl SecurityLogger {
    pub fn log_authentication_attempt(
        user_id: &str,
        success: bool,
        ip_address: Option<&str>
    ) {
        let event = SecurityEvent {
            timestamp: Utc::now(),
            event_type: "authentication".to_string(),
            severity: if success { "info" } else { "warning" }.to_string(),
            description: if success {
                "ユーザー認証成功".to_string()
            } else {
                "ユーザー認証失敗".to_string()
            },
            user_id: Some(user_id.to_string()),
            ip_address: ip_address.map(|s| s.to_string()),
            additional_data: None,
        };

        self.log_security_event(event);
    }

    pub fn log_file_access(
        user_id: &str,
        file_path: &str,
        operation: &str,
        success: bool
    ) {
        let event = SecurityEvent {
            timestamp: Utc::now(),
            event_type: "file_access".to_string(),
            severity: if success { "info" } else { "warning" }.to_string(),
            description: format!("ファイル{}: {}", operation, file_path),
            user_id: Some(user_id.to_string()),
            ip_address: None,
            additional_data: Some(serde_json::json!({
                "file_path": file_path,
                "operation": operation
            })),
        };

        self.log_security_event(event);
    }

    pub fn log_suspicious_activity(
        description: &str,
        additional_data: Option<serde_json::Value>
    ) {
        let event = SecurityEvent {
            timestamp: Utc::now(),
            event_type: "suspicious_activity".to_string(),
            severity: "error".to_string(),
            description: description.to_string(),
            user_id: None,
            ip_address: None,
            additional_data,
        };

        self.log_security_event(event);
    }

    fn log_security_event(&self, event: SecurityEvent) {
        let log_message = serde_json::to_string(&event).unwrap_or_else(|_| {
            "ログシリアライズ失敗".to_string()
        });

        match event.severity.as_str() {
            "info" => info!("SECURITY: {}", log_message),
            "warning" => warn!("SECURITY: {}", log_message),
            "error" => error!("SECURITY: {}", log_message),
            _ => info!("SECURITY: {}", log_message),
        }

        // 重要なセキュリティイベントは別途保存
        if event.severity == "error" || event.severity == "warning" {
            self.save_to_security_log(event);
        }
    }

    fn save_to_security_log(&self, event: SecurityEvent) {
        // セキュリティログファイルに保存
        tokio::spawn(async move {
            if let Ok(log_json) = serde_json::to_string(&event) {
                let log_entry = format!("{}\n", log_json);

                if let Err(e) = tokio::fs::OpenOptions::new()
                    .create(true)
                    .append(true)
                    .open("security.log")
                    .await
                    .and_then(|mut file| async move {
                        use tokio::io::AsyncWriteExt;
                        file.write_all(log_entry.as_bytes()).await
                    }.await)
                {
                    eprintln!("セキュリティログ書き込み失敗: {}", e);
                }
            }
        });
    }
}
```

## 次のステップ

パフォーマンスとセキュリティ対策を理解したら、[12\_実践的なアプリケーション設計.md](./12_実践的なアプリケーション設計.md) で総合的なアプリケーション設計パターンを学習し、最後に付録で実践的な参考情報を確認しましょう。
