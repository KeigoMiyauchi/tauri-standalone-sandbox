# 12. 実践的なアプリケーション設計

WPF アプリケーションでの MVVM パターンや Dependency Injection に相当する、Tauri アプリケーションでの総合的な設計パターンと実践的なアーキテクチャを解説します。

## 1. アーキテクチャ設計パターン

### フロントエンド：MVC パターンの実装

**1. Model（データモデル）**

```typescript
// src/models/User.ts
export interface User {
    id: number;
    name: string;
    email: string;
    createdAt: Date;
    isActive: boolean;
}

export class UserModel {
    constructor(
        public id: number,
        public name: string,
        public email: string,
        public createdAt: Date = new Date(),
        public isActive: boolean = true
    ) {}

    static fromJson(json: any): UserModel {
        return new UserModel(
            json.id,
            json.name,
            json.email,
            new Date(json.created_at),
            json.is_active
        );
    }

    toJson(): any {
        return {
            id: this.id,
            name: this.name,
            email: this.email,
            created_at: this.createdAt.toISOString(),
            is_active: this.isActive,
        };
    }

    validate(): { isValid: boolean; errors: string[] } {
        const errors: string[] = [];

        if (!this.name.trim()) {
            errors.push("名前は必須です");
        }

        if (!this.email.includes("@")) {
            errors.push("有効なメールアドレスを入力してください");
        }

        return {
            isValid: errors.length === 0,
            errors,
        };
    }
}

// src/models/AppState.ts
export interface AppState {
    users: UserModel[];
    currentUser: UserModel | null;
    isLoading: boolean;
    error: string | null;
    settings: AppSettings;
}

export interface AppSettings {
    theme: "light" | "dark";
    language: "ja" | "en";
    autoSave: boolean;
    notificationsEnabled: boolean;
}

export class StateManager {
    private state: AppState;
    private listeners: ((state: AppState) => void)[] = [];

    constructor() {
        this.state = {
            users: [],
            currentUser: null,
            isLoading: false,
            error: null,
            settings: {
                theme: "light",
                language: "ja",
                autoSave: true,
                notificationsEnabled: true,
            },
        };
    }

    getState(): AppState {
        return { ...this.state };
    }

    setState(newState: Partial<AppState>): void {
        this.state = { ...this.state, ...newState };
        this.notifyListeners();
    }

    subscribe(listener: (state: AppState) => void): () => void {
        this.listeners.push(listener);
        return () => {
            const index = this.listeners.indexOf(listener);
            if (index > -1) {
                this.listeners.splice(index, 1);
            }
        };
    }

    private notifyListeners(): void {
        this.listeners.forEach((listener) => listener(this.state));
    }
}
```

**2. Service（ビジネスロジック）**

```typescript
// src/services/UserService.ts
import { invoke } from "@tauri-apps/api/core";
import { UserModel } from "../models/User";

export interface IUserService {
    getUsers(): Promise<UserModel[]>;
    getUserById(id: number): Promise<UserModel | null>;
    createUser(user: Omit<UserModel, "id">): Promise<UserModel>;
    updateUser(user: UserModel): Promise<UserModel>;
    deleteUser(id: number): Promise<void>;
}

export class UserService implements IUserService {
    async getUsers(): Promise<UserModel[]> {
        try {
            const users = await invoke<any[]>("get_all_users");
            return users.map((user) => UserModel.fromJson(user));
        } catch (error) {
            throw new Error(`ユーザー一覧取得失敗: ${error}`);
        }
    }

    async getUserById(id: number): Promise<UserModel | null> {
        try {
            const user = await invoke<any>("get_user_by_id", { id });
            return user ? UserModel.fromJson(user) : null;
        } catch (error) {
            throw new Error(`ユーザー取得失敗: ${error}`);
        }
    }

    async createUser(userData: Omit<UserModel, "id">): Promise<UserModel> {
        const user = new UserModel(
            0,
            userData.name,
            userData.email,
            userData.createdAt,
            userData.isActive
        );
        const validation = user.validate();

        if (!validation.isValid) {
            throw new Error(
                `バリデーションエラー: ${validation.errors.join(", ")}`
            );
        }

        try {
            const createdUser = await invoke<any>("create_user", {
                user: user.toJson(),
            });
            return UserModel.fromJson(createdUser);
        } catch (error) {
            throw new Error(`ユーザー作成失敗: ${error}`);
        }
    }

    async updateUser(user: UserModel): Promise<UserModel> {
        const validation = user.validate();

        if (!validation.isValid) {
            throw new Error(
                `バリデーションエラー: ${validation.errors.join(", ")}`
            );
        }

        try {
            const updatedUser = await invoke<any>("update_user", {
                user: user.toJson(),
            });
            return UserModel.fromJson(updatedUser);
        } catch (error) {
            throw new Error(`ユーザー更新失敗: ${error}`);
        }
    }

    async deleteUser(id: number): Promise<void> {
        try {
            await invoke("delete_user", { id });
        } catch (error) {
            throw new Error(`ユーザー削除失敗: ${error}`);
        }
    }
}

// src/services/ServiceContainer.ts - Dependency Injection
export class ServiceContainer {
    private services = new Map<string, any>();

    register<T>(name: string, service: T): void {
        this.services.set(name, service);
    }

    get<T>(name: string): T {
        const service = this.services.get(name);
        if (!service) {
            throw new Error(`Service '${name}' not found`);
        }
        return service as T;
    }

    static create(): ServiceContainer {
        const container = new ServiceContainer();

        // サービスの登録
        container.register("userService", new UserService());
        container.register("stateManager", new StateManager());

        return container;
    }
}
```

**3. Controller（ビジネスロジック制御）**

```typescript
// src/controllers/UserController.ts
import { UserModel } from "../models/User";
import { IUserService } from "../services/UserService";
import { StateManager } from "../models/AppState";

export class UserController {
    constructor(
        private userService: IUserService,
        private stateManager: StateManager
    ) {}

    async loadUsers(): Promise<void> {
        this.stateManager.setState({ isLoading: true, error: null });

        try {
            const users = await this.userService.getUsers();
            this.stateManager.setState({
                users,
                isLoading: false,
            });
        } catch (error) {
            this.stateManager.setState({
                isLoading: false,
                error: error instanceof Error ? error.message : "不明なエラー",
            });
        }
    }

    async createUser(userData: { name: string; email: string }): Promise<void> {
        this.stateManager.setState({ isLoading: true, error: null });

        try {
            const newUser = await this.userService.createUser({
                name: userData.name,
                email: userData.email,
                createdAt: new Date(),
                isActive: true,
            });

            const currentState = this.stateManager.getState();
            this.stateManager.setState({
                users: [...currentState.users, newUser],
                isLoading: false,
            });
        } catch (error) {
            this.stateManager.setState({
                isLoading: false,
                error: error instanceof Error ? error.message : "不明なエラー",
            });
        }
    }

    async updateUser(user: UserModel): Promise<void> {
        this.stateManager.setState({ isLoading: true, error: null });

        try {
            const updatedUser = await this.userService.updateUser(user);
            const currentState = this.stateManager.getState();

            const updatedUsers = currentState.users.map((u) =>
                u.id === updatedUser.id ? updatedUser : u
            );

            this.stateManager.setState({
                users: updatedUsers,
                isLoading: false,
            });
        } catch (error) {
            this.stateManager.setState({
                isLoading: false,
                error: error instanceof Error ? error.message : "不明なエラー",
            });
        }
    }

    async deleteUser(id: number): Promise<void> {
        this.stateManager.setState({ isLoading: true, error: null });

        try {
            await this.userService.deleteUser(id);
            const currentState = this.stateManager.getState();

            const filteredUsers = currentState.users.filter((u) => u.id !== id);

            this.stateManager.setState({
                users: filteredUsers,
                isLoading: false,
            });
        } catch (error) {
            this.stateManager.setState({
                isLoading: false,
                error: error instanceof Error ? error.message : "不明なエラー",
            });
        }
    }

    selectUser(user: UserModel): void {
        this.stateManager.setState({ currentUser: user });
    }
}
```

**4. View（UI 描画）**

```typescript
// src/views/UserListView.ts
import { UserController } from "../controllers/UserController";
import { StateManager, AppState } from "../models/AppState";
import { UserModel } from "../models/User";

export class UserListView {
    private container: HTMLElement;
    private unsubscribe?: () => void;

    constructor(
        private userController: UserController,
        private stateManager: StateManager,
        containerId: string
    ) {
        const container = document.getElementById(containerId);
        if (!container) {
            throw new Error(`Container with id '${containerId}' not found`);
        }
        this.container = container;
        this.setupView();
        this.subscribeToState();
    }

    private setupView(): void {
        this.container.innerHTML = `
            <div class="user-list-container">
                <div class="user-list-header">
                    <h2>ユーザー管理</h2>
                    <button id="add-user-btn" class="btn btn-primary">新規追加</button>
                </div>
                
                <div id="loading-indicator" class="loading hidden">
                    読み込み中...
                </div>
                
                <div id="error-message" class="error hidden"></div>
                
                <div class="user-form hidden" id="user-form">
                    <h3 id="form-title">ユーザー追加</h3>
                    <form id="user-form-element">
                        <div class="form-group">
                            <label for="user-name">名前:</label>
                            <input type="text" id="user-name" required>
                        </div>
                        <div class="form-group">
                            <label for="user-email">メール:</label>
                            <input type="email" id="user-email" required>
                        </div>
                        <div class="form-actions">
                            <button type="submit" class="btn btn-primary">保存</button>
                            <button type="button" id="cancel-btn" class="btn btn-secondary">キャンセル</button>
                        </div>
                    </form>
                </div>
                
                <div class="user-list" id="user-list"></div>
            </div>
        `;

        this.setupEventListeners();
    }

    private setupEventListeners(): void {
        // 新規追加ボタン
        const addButton = document.getElementById("add-user-btn");
        addButton?.addEventListener("click", () => this.showUserForm());

        // フォーム送信
        const form = document.getElementById(
            "user-form-element"
        ) as HTMLFormElement;
        form?.addEventListener("submit", (e) => this.handleFormSubmit(e));

        // キャンセルボタン
        const cancelButton = document.getElementById("cancel-btn");
        cancelButton?.addEventListener("click", () => this.hideUserForm());
    }

    private subscribeToState(): void {
        this.unsubscribe = this.stateManager.subscribe((state) => {
            this.renderState(state);
        });

        // 初期データロード
        this.userController.loadUsers();
    }

    private renderState(state: AppState): void {
        this.renderLoadingIndicator(state.isLoading);
        this.renderError(state.error);
        this.renderUserList(state.users);
    }

    private renderLoadingIndicator(isLoading: boolean): void {
        const indicator = document.getElementById("loading-indicator");
        if (indicator) {
            indicator.classList.toggle("hidden", !isLoading);
        }
    }

    private renderError(error: string | null): void {
        const errorElement = document.getElementById("error-message");
        if (errorElement) {
            if (error) {
                errorElement.textContent = error;
                errorElement.classList.remove("hidden");
            } else {
                errorElement.classList.add("hidden");
            }
        }
    }

    private renderUserList(users: UserModel[]): void {
        const listContainer = document.getElementById("user-list");
        if (!listContainer) return;

        if (users.length === 0) {
            listContainer.innerHTML =
                '<p class="empty-message">ユーザーが登録されていません</p>';
            return;
        }

        listContainer.innerHTML = `
            <table class="user-table">
                <thead>
                    <tr>
                        <th>ID</th>
                        <th>名前</th>
                        <th>メール</th>
                        <th>作成日</th>
                        <th>状態</th>
                        <th>操作</th>
                    </tr>
                </thead>
                <tbody>
                    ${users.map((user) => this.renderUserRow(user)).join("")}
                </tbody>
            </table>
        `;

        // 操作ボタンのイベントリスナーを設定
        this.setupUserRowEventListeners(users);
    }

    private renderUserRow(user: UserModel): string {
        return `
            <tr data-user-id="${user.id}">
                <td>${user.id}</td>
                <td>${this.escapeHtml(user.name)}</td>
                <td>${this.escapeHtml(user.email)}</td>
                <td>${user.createdAt.toLocaleDateString("ja-JP")}</td>
                <td>
                    <span class="status ${
                        user.isActive ? "active" : "inactive"
                    }">
                        ${user.isActive ? "アクティブ" : "無効"}
                    </span>
                </td>
                <td>
                    <button class="btn btn-small edit-btn" data-user-id="${
                        user.id
                    }">編集</button>
                    <button class="btn btn-small btn-danger delete-btn" data-user-id="${
                        user.id
                    }">削除</button>
                </td>
            </tr>
        `;
    }

    private setupUserRowEventListeners(users: UserModel[]): void {
        // 編集ボタン
        document.querySelectorAll(".edit-btn").forEach((button) => {
            button.addEventListener("click", (e) => {
                const userId = parseInt(
                    (e.target as HTMLElement).dataset.userId || "0"
                );
                const user = users.find((u) => u.id === userId);
                if (user) {
                    this.showUserForm(user);
                }
            });
        });

        // 削除ボタン
        document.querySelectorAll(".delete-btn").forEach((button) => {
            button.addEventListener("click", (e) => {
                const userId = parseInt(
                    (e.target as HTMLElement).dataset.userId || "0"
                );
                this.handleDeleteUser(userId);
            });
        });
    }

    private showUserForm(user?: UserModel): void {
        const form = document.getElementById("user-form");
        const title = document.getElementById("form-title");
        const nameInput = document.getElementById(
            "user-name"
        ) as HTMLInputElement;
        const emailInput = document.getElementById(
            "user-email"
        ) as HTMLInputElement;

        if (form && title && nameInput && emailInput) {
            if (user) {
                title.textContent = "ユーザー編集";
                nameInput.value = user.name;
                emailInput.value = user.email;
                form.dataset.editUserId = user.id.toString();
            } else {
                title.textContent = "ユーザー追加";
                nameInput.value = "";
                emailInput.value = "";
                delete form.dataset.editUserId;
            }

            form.classList.remove("hidden");
        }
    }

    private hideUserForm(): void {
        const form = document.getElementById("user-form");
        if (form) {
            form.classList.add("hidden");
            delete form.dataset.editUserId;
        }
    }

    private async handleFormSubmit(e: Event): Promise<void> {
        e.preventDefault();

        const form = e.target as HTMLFormElement;
        const formData = new FormData(form);
        const name = (document.getElementById("user-name") as HTMLInputElement)
            .value;
        const email = (
            document.getElementById("user-email") as HTMLInputElement
        ).value;
        const editUserId = form.parentElement?.dataset.editUserId;

        try {
            if (editUserId) {
                // 編集
                const currentState = this.stateManager.getState();
                const user = currentState.users.find(
                    (u) => u.id === parseInt(editUserId)
                );
                if (user) {
                    user.name = name;
                    user.email = email;
                    await this.userController.updateUser(user);
                }
            } else {
                // 新規作成
                await this.userController.createUser({ name, email });
            }

            this.hideUserForm();
        } catch (error) {
            console.error("Form submission error:", error);
        }
    }

    private async handleDeleteUser(userId: number): Promise<void> {
        const confirmed = confirm("このユーザーを削除しますか？");
        if (confirmed) {
            await this.userController.deleteUser(userId);
        }
    }

    private escapeHtml(text: string): string {
        const div = document.createElement("div");
        div.textContent = text;
        return div.innerHTML;
    }

    destroy(): void {
        if (this.unsubscribe) {
            this.unsubscribe();
        }
    }
}
```

### バックエンド：レイヤードアーキテクチャ

**1. データアクセス層（Repository Pattern）**

```rust
// src-tauri/src/models/user.rs
use serde::{Deserialize, Serialize};
use chrono::{DateTime, Utc};

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct User {
    pub id: i32,
    pub name: String,
    pub email: String,
    pub created_at: DateTime<Utc>,
    pub is_active: bool,
}

#[derive(Debug, Deserialize)]
pub struct CreateUserRequest {
    pub name: String,
    pub email: String,
    pub created_at: DateTime<Utc>,
    pub is_active: bool,
}

#[derive(Debug, Deserialize)]
pub struct UpdateUserRequest {
    pub id: i32,
    pub name: String,
    pub email: String,
    pub is_active: bool,
}

// src-tauri/src/repositories/user_repository.rs
use async_trait::async_trait;
use sqlx::SqlitePool;
use crate::models::user::{User, CreateUserRequest, UpdateUserRequest};

#[async_trait]
pub trait UserRepository: Send + Sync {
    async fn get_all(&self) -> Result<Vec<User>, sqlx::Error>;
    async fn get_by_id(&self, id: i32) -> Result<Option<User>, sqlx::Error>;
    async fn create(&self, user: CreateUserRequest) -> Result<User, sqlx::Error>;
    async fn update(&self, user: UpdateUserRequest) -> Result<User, sqlx::Error>;
    async fn delete(&self, id: i32) -> Result<(), sqlx::Error>;
}

pub struct SqliteUserRepository {
    pool: SqlitePool,
}

impl SqliteUserRepository {
    pub fn new(pool: SqlitePool) -> Self {
        Self { pool }
    }
}

#[async_trait]
impl UserRepository for SqliteUserRepository {
    async fn get_all(&self) -> Result<Vec<User>, sqlx::Error> {
        let users = sqlx::query_as!(
            User,
            r#"
            SELECT id, name, email, created_at, is_active
            FROM users
            ORDER BY created_at DESC
            "#
        )
        .fetch_all(&self.pool)
        .await?;

        Ok(users)
    }

    async fn get_by_id(&self, id: i32) -> Result<Option<User>, sqlx::Error> {
        let user = sqlx::query_as!(
            User,
            r#"
            SELECT id, name, email, created_at, is_active
            FROM users
            WHERE id = ?
            "#,
            id
        )
        .fetch_optional(&self.pool)
        .await?;

        Ok(user)
    }

    async fn create(&self, user: CreateUserRequest) -> Result<User, sqlx::Error> {
        let result = sqlx::query!(
            r#"
            INSERT INTO users (name, email, created_at, is_active)
            VALUES (?, ?, ?, ?)
            "#,
            user.name,
            user.email,
            user.created_at,
            user.is_active
        )
        .execute(&self.pool)
        .await?;

        let user_id = result.last_insert_rowid() as i32;

        // 作成されたユーザーを取得
        self.get_by_id(user_id).await?.ok_or_else(||
            sqlx::Error::RowNotFound
        )
    }

    async fn update(&self, user: UpdateUserRequest) -> Result<User, sqlx::Error> {
        sqlx::query!(
            r#"
            UPDATE users
            SET name = ?, email = ?, is_active = ?
            WHERE id = ?
            "#,
            user.name,
            user.email,
            user.is_active,
            user.id
        )
        .execute(&self.pool)
        .await?;

        // 更新されたユーザーを取得
        self.get_by_id(user.id).await?.ok_or_else(||
            sqlx::Error::RowNotFound
        )
    }

    async fn delete(&self, id: i32) -> Result<(), sqlx::Error> {
        sqlx::query!(
            "DELETE FROM users WHERE id = ?",
            id
        )
        .execute(&self.pool)
        .await?;

        Ok(())
    }
}
```

**2. ビジネスロジック層（Service Pattern）**

```rust
// src-tauri/src/services/user_service.rs
use crate::repositories::user_repository::UserRepository;
use crate::models::user::{User, CreateUserRequest, UpdateUserRequest};
use std::sync::Arc;

#[derive(Debug)]
pub enum UserServiceError {
    ValidationError(String),
    NotFound,
    DatabaseError(sqlx::Error),
}

impl From<sqlx::Error> for UserServiceError {
    fn from(error: sqlx::Error) -> Self {
        UserServiceError::DatabaseError(error)
    }
}

pub struct UserService {
    repository: Arc<dyn UserRepository>,
}

impl UserService {
    pub fn new(repository: Arc<dyn UserRepository>) -> Self {
        Self { repository }
    }

    pub async fn get_all_users(&self) -> Result<Vec<User>, UserServiceError> {
        self.repository.get_all().await.map_err(UserServiceError::from)
    }

    pub async fn get_user_by_id(&self, id: i32) -> Result<Option<User>, UserServiceError> {
        self.repository.get_by_id(id).await.map_err(UserServiceError::from)
    }

    pub async fn create_user(&self, user: CreateUserRequest) -> Result<User, UserServiceError> {
        // バリデーション
        self.validate_user_data(&user.name, &user.email)?;

        // 重複チェック
        if self.email_exists(&user.email).await? {
            return Err(UserServiceError::ValidationError(
                "このメールアドレスは既に使用されています".to_string()
            ));
        }

        self.repository.create(user).await.map_err(UserServiceError::from)
    }

    pub async fn update_user(&self, user: UpdateUserRequest) -> Result<User, UserServiceError> {
        // バリデーション
        self.validate_user_data(&user.name, &user.email)?;

        // 存在チェック
        if self.repository.get_by_id(user.id).await?.is_none() {
            return Err(UserServiceError::NotFound);
        }

        // 重複チェック（自分以外）
        if self.email_exists_excluding_id(&user.email, user.id).await? {
            return Err(UserServiceError::ValidationError(
                "このメールアドレスは既に使用されています".to_string()
            ));
        }

        self.repository.update(user).await.map_err(UserServiceError::from)
    }

    pub async fn delete_user(&self, id: i32) -> Result<(), UserServiceError> {
        // 存在チェック
        if self.repository.get_by_id(id).await?.is_none() {
            return Err(UserServiceError::NotFound);
        }

        self.repository.delete(id).await.map_err(UserServiceError::from)
    }

    fn validate_user_data(&self, name: &str, email: &str) -> Result<(), UserServiceError> {
        if name.trim().is_empty() {
            return Err(UserServiceError::ValidationError(
                "名前は必須です".to_string()
            ));
        }

        if name.len() > 100 {
            return Err(UserServiceError::ValidationError(
                "名前は100文字以下である必要があります".to_string()
            ));
        }

        if !email.contains('@') {
            return Err(UserServiceError::ValidationError(
                "有効なメールアドレスを入力してください".to_string()
            ));
        }

        if email.len() > 254 {
            return Err(UserServiceError::ValidationError(
                "メールアドレスが長すぎます".to_string()
            ));
        }

        Ok(())
    }

    async fn email_exists(&self, email: &str) -> Result<bool, UserServiceError> {
        // 簡略化のため、実装省略
        Ok(false)
    }

    async fn email_exists_excluding_id(&self, email: &str, exclude_id: i32) -> Result<bool, UserServiceError> {
        // 簡略化のため、実装省略
        Ok(false)
    }
}
```

**3. プレゼンテーション層（Command Handlers）**

```rust
// src-tauri/src/commands/user_commands.rs
use tauri::State;
use crate::services::user_service::{UserService, UserServiceError};
use crate::models::user::{User, CreateUserRequest, UpdateUserRequest};
use std::sync::Arc;

#[derive(serde::Serialize)]
pub struct ErrorResponse {
    pub code: String,
    pub message: String,
}

impl From<UserServiceError> for ErrorResponse {
    fn from(error: UserServiceError) -> Self {
        match error {
            UserServiceError::ValidationError(msg) => ErrorResponse {
                code: "VALIDATION_ERROR".to_string(),
                message: msg,
            },
            UserServiceError::NotFound => ErrorResponse {
                code: "NOT_FOUND".to_string(),
                message: "ユーザーが見つかりません".to_string(),
            },
            UserServiceError::DatabaseError(_) => ErrorResponse {
                code: "DATABASE_ERROR".to_string(),
                message: "データベースエラーが発生しました".to_string(),
            },
        }
    }
}

#[tauri::command]
pub async fn get_all_users(
    user_service: State<'_, Arc<UserService>>
) -> Result<Vec<User>, ErrorResponse> {
    user_service.get_all_users().await.map_err(ErrorResponse::from)
}

#[tauri::command]
pub async fn get_user_by_id(
    id: i32,
    user_service: State<'_, Arc<UserService>>
) -> Result<Option<User>, ErrorResponse> {
    user_service.get_user_by_id(id).await.map_err(ErrorResponse::from)
}

#[tauri::command]
pub async fn create_user(
    user: CreateUserRequest,
    user_service: State<'_, Arc<UserService>>
) -> Result<User, ErrorResponse> {
    user_service.create_user(user).await.map_err(ErrorResponse::from)
}

#[tauri::command]
pub async fn update_user(
    user: UpdateUserRequest,
    user_service: State<'_, Arc<UserService>>
) -> Result<User, ErrorResponse> {
    user_service.update_user(user).await.map_err(ErrorResponse::from)
}

#[tauri::command]
pub async fn delete_user(
    id: i32,
    user_service: State<'_, Arc<UserService>>
) -> Result<(), ErrorResponse> {
    user_service.delete_user(id).await.map_err(ErrorResponse::from)
}
```

## 2. アプリケーション全体の統合

### メインアプリケーションの初期化

```typescript
// src/main.ts
import { ServiceContainer } from "./services/ServiceContainer";
import { UserListView } from "./views/UserListView";
import { UserController } from "./controllers/UserController";
import "./styles/main.css";

class Application {
    private serviceContainer: ServiceContainer;
    private userListView?: UserListView;

    constructor() {
        this.serviceContainer = ServiceContainer.create();
    }

    async initialize(): Promise<void> {
        try {
            // サービスの取得
            const userService = this.serviceContainer.get("userService");
            const stateManager = this.serviceContainer.get("stateManager");

            // コントローラーの作成
            const userController = new UserController(
                userService,
                stateManager
            );

            // ビューの作成
            this.userListView = new UserListView(
                userController,
                stateManager,
                "app"
            );

            console.log("アプリケーション初期化完了");
        } catch (error) {
            console.error("アプリケーション初期化失敗:", error);
            this.showErrorScreen(error);
        }
    }

    private showErrorScreen(error: any): void {
        const appElement = document.getElementById("app");
        if (appElement) {
            appElement.innerHTML = `
                <div class="error-screen">
                    <h1>アプリケーションエラー</h1>
                    <p>アプリケーションの初期化に失敗しました。</p>
                    <p>エラー: ${
                        error instanceof Error ? error.message : "不明なエラー"
                    }</p>
                    <button onclick="location.reload()">再読み込み</button>
                </div>
            `;
        }
    }

    destroy(): void {
        this.userListView?.destroy();
    }
}

// アプリケーション起動
document.addEventListener("DOMContentLoaded", async () => {
    const app = new Application();
    await app.initialize();

    // アプリケーション終了時のクリーンアップ
    window.addEventListener("beforeunload", () => {
        app.destroy();
    });
});
```

### Rust メインアプリケーション

```rust
// src-tauri/src/main.rs
mod models;
mod repositories;
mod services;
mod commands;

use repositories::user_repository::SqliteUserRepository;
use services::user_service::UserService;
use commands::user_commands::*;
use sqlx::SqlitePool;
use std::sync::Arc;

#[cfg_attr(mobile, tauri::mobile_entry_point)]
pub async fn run() -> Result<(), Box<dyn std::error::Error>> {
    // データベース初期化
    let database_url = "sqlite:app.db";
    let pool = SqlitePool::connect(database_url).await?;

    // マイグレーション実行
    sqlx::migrate!("./migrations").run(&pool).await?;

    // リポジトリとサービスの作成
    let user_repository = Arc::new(SqliteUserRepository::new(pool));
    let user_service = Arc::new(UserService::new(user_repository));

    // Tauriアプリケーション起動
    tauri::Builder::default()
        .manage(user_service)
        .invoke_handler(tauri::generate_handler![
            get_all_users,
            get_user_by_id,
            create_user,
            update_user,
            delete_user
        ])
        .run(tauri::generate_context!())
        .expect("error while running tauri application");

    Ok(())
}

#[tokio::main]
async fn main() {
    if let Err(e) = run().await {
        eprintln!("アプリケーション起動失敗: {}", e);
        std::process::exit(1);
    }
}
```

## 3. 設定管理とプラグインシステム

### 設定管理の実装

```typescript
// src/config/AppConfig.ts
export interface AppConfig {
    database: {
        path: string;
        backupInterval: number;
    };
    ui: {
        theme: "light" | "dark";
        language: "ja" | "en";
        pageSize: number;
    };
    features: {
        autoSave: boolean;
        notifications: boolean;
        analytics: boolean;
    };
}

export class ConfigManager {
    private config: AppConfig;
    private readonly configFile = "app-config.json";

    constructor() {
        this.config = this.getDefaultConfig();
    }

    async load(): Promise<void> {
        try {
            const configData = await invoke<string>("load_config", {
                filename: this.configFile,
            });
            this.config = { ...this.config, ...JSON.parse(configData) };
        } catch (error) {
            console.warn(
                "設定ファイルの読み込みに失敗、デフォルト設定を使用:",
                error
            );
            await this.save(); // デフォルト設定を保存
        }
    }

    async save(): Promise<void> {
        try {
            await invoke("save_config", {
                filename: this.configFile,
                data: JSON.stringify(this.config, null, 2),
            });
        } catch (error) {
            console.error("設定の保存に失敗:", error);
            throw error;
        }
    }

    get(): AppConfig {
        return { ...this.config };
    }

    update(updates: Partial<AppConfig>): void {
        this.config = this.mergeDeep(this.config, updates);
    }

    private getDefaultConfig(): AppConfig {
        return {
            database: {
                path: "app.db",
                backupInterval: 24 * 60 * 60 * 1000, // 24時間
            },
            ui: {
                theme: "light",
                language: "ja",
                pageSize: 20,
            },
            features: {
                autoSave: true,
                notifications: true,
                analytics: false,
            },
        };
    }

    private mergeDeep(target: any, source: any): any {
        const result = { ...target };

        for (const key in source) {
            if (source[key] !== null && typeof source[key] === "object") {
                result[key] = this.mergeDeep(target[key] || {}, source[key]);
            } else {
                result[key] = source[key];
            }
        }

        return result;
    }
}
```

## 4. パフォーマンス監視

```typescript
// src/monitoring/PerformanceMonitor.ts
export class PerformanceMonitor {
    private metrics: Map<string, number[]> = new Map();

    startMeasurement(operation: string): () => number {
        const startTime = performance.now();

        return (): number => {
            const duration = performance.now() - startTime;
            this.recordMetric(operation, duration);
            return duration;
        };
    }

    private recordMetric(operation: string, duration: number): void {
        if (!this.metrics.has(operation)) {
            this.metrics.set(operation, []);
        }

        const measurements = this.metrics.get(operation)!;
        measurements.push(duration);

        // 最新100件のみ保持
        if (measurements.length > 100) {
            measurements.shift();
        }
    }

    getAverageTime(operation: string): number {
        const measurements = this.metrics.get(operation);
        if (!measurements || measurements.length === 0) {
            return 0;
        }

        const sum = measurements.reduce((acc, time) => acc + time, 0);
        return sum / measurements.length;
    }

    getMetricsReport(): Record<string, { average: number; count: number }> {
        const report: Record<string, { average: number; count: number }> = {};

        for (const [operation, measurements] of this.metrics) {
            report[operation] = {
                average: this.getAverageTime(operation),
                count: measurements.length,
            };
        }

        return report;
    }
}
```

この実践的なアプリケーション設計により、WPF から移行する開発者も馴染みやすい構造で Tauri アプリケーションを構築できます。次は付録として、実際の開発で役立つ参考情報をまとめます。
