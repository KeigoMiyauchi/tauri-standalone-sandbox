# 09. エラーハンドリングとデバッグ

WPF での try-catch 文や Visual Studio デバッガーに相当する、Tauri でのエラーハンドリングとデバッグ手法を解説します。

## 1. エラーハンドリングの基本

### WPF のエラーハンドリング（参考）

```csharp
try
{
    var content = File.ReadAllText(filePath);
    DisplayContent(content);
}
catch (FileNotFoundException ex)
{
    MessageBox.Show($"ファイルが見つかりません: {ex.Message}");
}
catch (UnauthorizedAccessException ex)
{
    MessageBox.Show($"アクセス権限がありません: {ex.Message}");
}
catch (Exception ex)
{
    MessageBox.Show($"予期しないエラーが発生しました: {ex.Message}");
    Logger.LogError(ex);
}
```

### Tauri のエラーハンドリング

**TypeScript 側（フロントエンド）**

```typescript
// カスタムエラークラス
class AppError extends Error {
    constructor(public code: string, message: string, public details?: any) {
        super(message);
        this.name = "AppError";
    }
}

// エラーハンドリング用ユーティリティ
class ErrorHandler {
    static async handleAsyncOperation<T>(
        operation: () => Promise<T>,
        errorContext: string
    ): Promise<T> {
        try {
            return await operation();
        } catch (error) {
            this.logError(error, errorContext);
            throw this.processError(error);
        }
    }

    static processError(error: any): AppError {
        if (error instanceof AppError) {
            return error;
        }

        if (typeof error === "string") {
            try {
                // Rustからのエラーレスポンスを解析
                const parsedError = JSON.parse(error);
                return new AppError(
                    parsedError.code || "UNKNOWN_ERROR",
                    parsedError.message || error,
                    parsedError
                );
            } catch {
                return new AppError("UNKNOWN_ERROR", error);
            }
        }

        if (error instanceof Error) {
            return new AppError("JAVASCRIPT_ERROR", error.message, error);
        }

        return new AppError(
            "UNKNOWN_ERROR",
            "予期しないエラーが発生しました",
            error
        );
    }

    static logError(error: any, context: string): void {
        const timestamp = new Date().toISOString();
        const errorInfo = {
            timestamp,
            context,
            error:
                error instanceof Error
                    ? {
                          name: error.name,
                          message: error.message,
                          stack: error.stack,
                      }
                    : error,
        };

        console.error("アプリケーションエラー:", errorInfo);

        // 本番環境では外部ログサービスに送信
        if (import.meta.env.PROD) {
            this.sendToLogService(errorInfo);
        }
    }

    static async sendToLogService(errorInfo: any): Promise<void> {
        // 実装例：外部ログサービスへの送信
        try {
            await fetch("/api/logs", {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify(errorInfo),
            });
        } catch {
            // ログ送信の失敗は無視（無限ループを避ける）
        }
    }

    static showUserFriendlyError(error: AppError): void {
        let userMessage: string;

        switch (error.code) {
            case "FILE_NOT_FOUND":
                userMessage =
                    "ファイルが見つかりません。ファイルパスを確認してください。";
                break;
            case "PERMISSION_DENIED":
                userMessage = "ファイルへのアクセス権限がありません。";
                break;
            case "NETWORK_ERROR":
                userMessage =
                    "ネットワークエラーが発生しました。インターネット接続を確認してください。";
                break;
            case "VALIDATION_ERROR":
                userMessage = `入力データに問題があります: ${error.message}`;
                break;
            default:
                userMessage = `エラーが発生しました: ${error.message}`;
        }

        this.showErrorDialog(userMessage, error.code);
    }

    static showErrorDialog(message: string, errorCode?: string): void {
        const dialog = document.getElementById(
            "error-dialog"
        ) as HTMLDialogElement;
        const messageEl = document.getElementById("error-message");
        const codeEl = document.getElementById("error-code");

        if (messageEl) messageEl.textContent = message;
        if (codeEl && errorCode)
            codeEl.textContent = `エラーコード: ${errorCode}`;

        dialog?.showModal();
    }
}

// 使用例
async function loadFileWithErrorHandling(filePath: string): Promise<void> {
    await ErrorHandler.handleAsyncOperation(async () => {
        const content = await invoke<string>("read_file", { path: filePath });
        const editor = document.getElementById("editor") as HTMLTextAreaElement;
        editor.value = content;
    }, `ファイル読み込み: ${filePath}`);
}

// グローバルエラーハンドラー
window.addEventListener("error", (event) => {
    ErrorHandler.logError(event.error, "Global Error Handler");
});

window.addEventListener("unhandledrejection", (event) => {
    ErrorHandler.logError(event.reason, "Unhandled Promise Rejection");
    event.preventDefault(); // デフォルトのエラー表示を抑制
});
```

**Rust 側（バックエンド）**

```rust
use serde::Serialize;
use std::fmt;

// カスタムエラー型の定義
#[derive(Debug, Serialize)]
pub struct AppError {
    pub code: String,
    pub message: String,
    pub details: Option<String>,
}

impl fmt::Display for AppError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}: {}", self.code, self.message)
    }
}

impl std::error::Error for AppError {}

// 各種エラーからの変換実装
impl From<std::io::Error> for AppError {
    fn from(error: std::io::Error) -> Self {
        let code = match error.kind() {
            std::io::ErrorKind::NotFound => "FILE_NOT_FOUND",
            std::io::ErrorKind::PermissionDenied => "PERMISSION_DENIED",
            std::io::ErrorKind::AlreadyExists => "FILE_ALREADY_EXISTS",
            _ => "IO_ERROR",
        };

        AppError {
            code: code.to_string(),
            message: error.to_string(),
            details: Some(format!("IO Error Kind: {:?}", error.kind())),
        }
    }
}

impl From<serde_json::Error> for AppError {
    fn from(error: serde_json::Error) -> Self {
        AppError {
            code: "JSON_PARSE_ERROR".to_string(),
            message: "JSONの解析に失敗しました".to_string(),
            details: Some(error.to_string()),
        }
    }
}

// バリデーションエラー
#[derive(Debug)]
pub struct ValidationError {
    pub field: String,
    pub message: String,
}

impl From<ValidationError> for AppError {
    fn from(error: ValidationError) -> Self {
        AppError {
            code: "VALIDATION_ERROR".to_string(),
            message: format!("{}: {}", error.field, error.message),
            details: None,
        }
    }
}

// エラーハンドリング付きのコマンド例
#[tauri::command]
async fn read_file_safe(path: String) -> Result<String, AppError> {
    // パスの検証
    if path.is_empty() {
        return Err(ValidationError {
            field: "path".to_string(),
            message: "ファイルパスが空です".to_string(),
        }.into());
    }

    // ファイル読み込み
    let content = std::fs::read_to_string(&path)?;

    // 内容の検証
    if content.len() > 1_000_000 {
        return Err(AppError {
            code: "FILE_TOO_LARGE".to_string(),
            message: "ファイルサイズが大きすぎます（1MB以下である必要があります）".to_string(),
            details: Some(format!("ファイルサイズ: {} bytes", content.len())),
        });
    }

    Ok(content)
}

#[tauri::command]
async fn save_file_safe(path: String, content: String) -> Result<(), AppError> {
    // 入力検証
    if path.is_empty() {
        return Err(ValidationError {
            field: "path".to_string(),
            message: "ファイルパスが空です".to_string(),
        }.into());
    }

    if content.len() > 1_000_000 {
        return Err(AppError {
            code: "CONTENT_TOO_LARGE".to_string(),
            message: "保存する内容が大きすぎます".to_string(),
            details: Some(format!("内容サイズ: {} bytes", content.len())),
        });
    }

    // ディレクトリの作成
    if let Some(parent) = std::path::Path::new(&path).parent() {
        std::fs::create_dir_all(parent)?;
    }

    // ファイル保存
    std::fs::write(&path, content)?;

    println!("ファイル保存完了: {}", path);
    Ok(())
}

// ログ機能
#[tauri::command]
async fn log_error(error_info: serde_json::Value) -> Result<(), AppError> {
    let log_entry = format!(
        "[{}] ERROR: {}",
        chrono::Utc::now().format("%Y-%m-%d %H:%M:%S UTC"),
        error_info
    );

    // ログファイルに記録
    let log_path = "app_errors.log";
    let mut file = std::fs::OpenOptions::new()
        .create(true)
        .append(true)
        .open(log_path)?;

    use std::io::Write;
    writeln!(file, "{}", log_entry)?;

    Ok(())
}
```

## 2. デバッグ手法

### 開発時のデバッグ

**1. コンソールログの活用**

```typescript
// デバッグレベル別のログ関数
class Logger {
    static debug(message: string, data?: any): void {
        if (import.meta.env.DEV) {
            console.debug(`[DEBUG] ${message}`, data || "");
        }
    }

    static info(message: string, data?: any): void {
        console.info(`[INFO] ${message}`, data || "");
    }

    static warn(message: string, data?: any): void {
        console.warn(`[WARN] ${message}`, data || "");
    }

    static error(message: string, error?: any): void {
        console.error(`[ERROR] ${message}`, error || "");
    }
}

// 使用例
async function loadData() {
    Logger.debug("データ読み込み開始");

    try {
        const data = await invoke("get_data");
        Logger.info("データ読み込み成功", { recordCount: data.length });
        return data;
    } catch (error) {
        Logger.error("データ読み込み失敗", error);
        throw error;
    }
}
```

**2. Rust 側のログ**

```rust
// Cargo.tomlに追加
// [dependencies]
// log = "0.4"
// env_logger = "0.10"

use log::{debug, info, warn, error};

#[tauri::command]
async fn debug_operation(input: String) -> Result<String, String> {
    debug!("debug_operation called with input: {}", input);

    if input.is_empty() {
        warn!("Empty input provided to debug_operation");
        return Err("入力が空です".to_string());
    }

    info!("Processing input of length: {}", input.len());

    let result = format!("Processed: {}", input.to_uppercase());

    debug!("debug_operation returning: {}", result);
    Ok(result)
}

// main関数でロガーを初期化
fn main() {
    env_logger::init();

    tauri::Builder::default()
        .invoke_handler(tauri::generate_handler![debug_operation])
        .run(tauri::generate_context!())
        .expect("error while running tauri application");
}
```

**3. VS Code でのデバッグ設定**

`.vscode/launch.json`

```json
{
    "version": "0.2.0",
    "configurations": [
        {
            "name": "Tauri Development Debug",
            "type": "node",
            "request": "launch",
            "cwd": "${workspaceFolder}",
            "runtimeExecutable": "npm",
            "runtimeArgs": ["run", "tauri", "dev"],
            "skipFiles": ["<node_internals>/**"],
            "env": {
                "RUST_LOG": "debug"
            }
        },
        {
            "name": "Debug Rust Backend",
            "type": "lldb",
            "request": "launch",
            "program": "${workspaceFolder}/src-tauri/target/debug/your-app-name",
            "cwd": "${workspaceFolder}/src-tauri",
            "env": {
                "RUST_LOG": "debug"
            }
        }
    ]
}
```

### 実行時デバッグ

**1. DevTools の有効化**

```rust
// src-tauri/tauri.conf.json
{
  "app": {
    "withGlobalTauri": true,
    "windows": [
      {
        "title": "My App",
        "width": 800,
        "height": 600,
        "devtools": true  // 開発時のみ有効にする
      }
    ]
  }
}
```

**2. パフォーマンス測定**

```typescript
class PerformanceMonitor {
    private static measurements = new Map<string, number>();

    static start(label: string): void {
        this.measurements.set(label, performance.now());
        console.time(label);
    }

    static end(label: string): number {
        const startTime = this.measurements.get(label);
        if (startTime) {
            const duration = performance.now() - startTime;
            console.timeEnd(label);
            this.measurements.delete(label);
            return duration;
        }
        return 0;
    }

    static async measure<T>(
        label: string,
        operation: () => Promise<T>
    ): Promise<T> {
        this.start(label);
        try {
            const result = await operation();
            return result;
        } finally {
            this.end(label);
        }
    }
}

// 使用例
async function heavyOperation(): Promise<void> {
    await PerformanceMonitor.measure("Heavy Operation", async () => {
        await invoke("complex_calculation");
    });
}
```

## 3. 単体テストと E2E テスト

**TypeScript 単体テスト（Vitest）**

`package.json`に追加:

```json
{
    "devDependencies": {
        "vitest": "^1.0.0",
        "@vitest/ui": "^1.0.0"
    },
    "scripts": {
        "test": "vitest",
        "test:ui": "vitest --ui"
    }
}
```

テストファイル例（`src/tests/fileManager.test.ts`）:

```typescript
import { describe, it, expect, beforeEach, vi } from "vitest";
import { FileManager } from "../fileManager";

// mockTauriをインポート
const mockInvoke = vi.fn();
vi.mock("@tauri-apps/api/core", () => ({
    invoke: mockInvoke,
}));

describe("FileManager", () => {
    let fileManager: FileManager;

    beforeEach(() => {
        fileManager = new FileManager();
        mockInvoke.mockClear();
    });

    it("should load file successfully", async () => {
        const expectedContent = "test content";
        mockInvoke.mockResolvedValue(expectedContent);

        const result = await fileManager.loadFile("test.txt");

        expect(mockInvoke).toHaveBeenCalledWith("read_text_file", {
            path: "test.txt",
        });
        expect(result).toBe(expectedContent);
    });

    it("should handle file not found error", async () => {
        const error = new Error("File not found");
        mockInvoke.mockRejectedValue(error);

        await expect(fileManager.loadFile("nonexistent.txt")).rejects.toThrow(
            "ファイル読み込み失敗"
        );
    });
});
```

**Rust 単体テスト**

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_validate_input() {
        let result = validate_input("valid input");
        assert!(result.is_ok());

        let result = validate_input("");
        assert!(result.is_err());
        assert_eq!(result.unwrap_err().code, "VALIDATION_ERROR");
    }

    #[tokio::test]
    async fn test_read_file_safe() {
        // テスト用一時ファイルを作成
        let temp_path = "test_file.txt";
        std::fs::write(temp_path, "test content").unwrap();

        let result = read_file_safe(temp_path.to_string()).await;
        assert!(result.is_ok());
        assert_eq!(result.unwrap(), "test content");

        // クリーンアップ
        std::fs::remove_file(temp_path).unwrap();
    }

    #[tokio::test]
    async fn test_read_nonexistent_file() {
        let result = read_file_safe("nonexistent.txt".to_string()).await;
        assert!(result.is_err());
        assert_eq!(result.unwrap_err().code, "FILE_NOT_FOUND");
    }
}
```

## 4. プロダクションでのエラー監視

```typescript
class ProductionErrorHandler {
    private static readonly MAX_ERRORS_PER_SESSION = 10;
    private static errorCount = 0;

    static initializeProductionErrorHandling(): void {
        if (import.meta.env.PROD) {
            this.setupGlobalErrorHandlers();
            this.startErrorReporting();
        }
    }

    private static setupGlobalErrorHandlers(): void {
        window.addEventListener("error", (event) => {
            this.reportError({
                type: "javascript_error",
                message: event.message,
                filename: event.filename,
                lineno: event.lineno,
                colno: event.colno,
                stack: event.error?.stack,
            });
        });

        window.addEventListener("unhandledrejection", (event) => {
            this.reportError({
                type: "unhandled_promise_rejection",
                reason: event.reason,
            });
        });
    }

    private static async reportError(errorData: any): Promise<void> {
        if (this.errorCount >= this.MAX_ERRORS_PER_SESSION) {
            return; // エラー過多を防ぐ
        }

        this.errorCount++;

        try {
            await invoke("log_error", {
                errorInfo: {
                    ...errorData,
                    timestamp: new Date().toISOString(),
                    userAgent: navigator.userAgent,
                    url: window.location.href,
                },
            });
        } catch {
            // エラーレポートの失敗は無視
        }
    }

    private static startErrorReporting(): void {
        // 定期的にエラーカウントをリセット
        setInterval(() => {
            this.errorCount = 0;
        }, 60000); // 1分ごと
    }
}

// アプリケーション起動時に初期化
document.addEventListener("DOMContentLoaded", () => {
    ProductionErrorHandler.initializeProductionErrorHandling();
});
```

## 次のステップ

エラーハンドリングとデバッグ手法を理解したら、[10\_配布とデプロイメント.md](./10_配布とデプロイメント.md) でアプリケーションの配布方法を学習しましょう。
