# 10. 配布とデプロイメント

WPF アプリケーションの MSI インストーラー作成に相当する、Tauri アプリケーションの配布とデプロイメント手法を解説します。

## 1. ビルド設定と最適化

### 本番ビルドの準備

**tauri.conf.json の本番設定**

```json
{
    "app": {
        "withGlobalTauri": false,
        "windows": [
            {
                "title": "My Application",
                "width": 1024,
                "height": 768,
                "resizable": true,
                "fullscreen": false,
                "devtools": false
            }
        ]
    },
    "build": {
        "beforeBuildCommand": "npm run build",
        "beforeDevCommand": "npm run dev",
        "devUrl": "http://localhost:1420",
        "frontendDist": "../dist"
    },
    "bundle": {
        "active": true,
        "targets": ["dmg", "app"],
        "identifier": "com.yourcompany.yourapp",
        "icon": [
            "icons/32x32.png",
            "icons/128x128.png",
            "icons/128x128@2x.png",
            "icons/icon.icns",
            "icons/icon.ico"
        ],
        "resources": [],
        "externalBin": [],
        "copyright": "Copyright © 2024 Your Company",
        "category": "Utility",
        "shortDescription": "アプリケーションの短い説明",
        "longDescription": "アプリケーションの詳細な説明文",
        "deb": {
            "depends": []
        },
        "macOS": {
            "frameworks": [],
            "minimumSystemVersion": "10.15",
            "exceptionDomain": "",
            "signingIdentity": null,
            "entitlements": null
        },
        "windows": {
            "certificateThumbprint": null,
            "digestAlgorithm": "sha256",
            "timestampUrl": ""
        }
    }
}
```

### 本番環境用の環境変数設定

**.env.production**

```bash
VITE_APP_NAME=My Production App
VITE_APP_VERSION=1.0.0
VITE_API_BASE_URL=https://api.yourcompany.com
VITE_ENABLE_LOGGING=false
VITE_ENABLE_ANALYTICS=true
```

**package.json のビルドスクリプト**

```json
{
    "scripts": {
        "dev": "vite",
        "build": "vite build",
        "build:prod": "NODE_ENV=production vite build",
        "preview": "vite preview",
        "tauri": "tauri",
        "tauri:dev": "tauri dev",
        "tauri:build": "tauri build",
        "tauri:build:debug": "tauri build --debug",
        "release": "npm run build:prod && tauri build",
        "release:sign": "npm run build:prod && tauri build --config src-tauri/tauri.sign.conf.json"
    }
}
```

## 2. アイコンとリソースの準備

### アイコンファイルの作成

**必要なアイコンサイズ（macOS）**

```bash
# アイコン生成用のスクリプト（icon-generator.sh）
#!/bin/bash

# 元画像（1024x1024の高解像度PNG）からアイコンを生成
SOURCE_IMAGE="icon-source.png"
ICONS_DIR="src-tauri/icons"

mkdir -p $ICONS_DIR

# macOS用アイコン生成
sips -z 32 32 $SOURCE_IMAGE --out $ICONS_DIR/32x32.png
sips -z 128 128 $SOURCE_IMAGE --out $ICONS_DIR/128x128.png
sips -z 256 256 $SOURCE_IMAGE --out $ICONS_DIR/128x128@2x.png
sips -z 256 256 $SOURCE_IMAGE --out $ICONS_DIR/256x256.png
sips -z 512 512 $SOURCE_IMAGE --out $ICONS_DIR/256x256@2x.png
sips -z 512 512 $SOURCE_IMAGE --out $ICONS_DIR/512x512.png
sips -z 1024 1024 $SOURCE_IMAGE --out $ICONS_DIR/512x512@2x.png

# .icns ファイル作成（macOS）
mkdir icon.iconset
cp $ICONS_DIR/32x32.png icon.iconset/icon_32x32.png
cp $ICONS_DIR/128x128.png icon.iconset/icon_128x128.png
cp $ICONS_DIR/256x256.png icon.iconset/icon_128x128@2x.png
cp $ICONS_DIR/256x256.png icon.iconset/icon_256x256.png
cp $ICONS_DIR/512x512.png icon.iconset/icon_256x256@2x.png
cp $ICONS_DIR/512x512.png icon.iconset/icon_512x512.png
cp $ICONS_DIR/512x512@2x.png icon.iconset/icon_512x512@2x.png

iconutil -c icns icon.iconset
mv icon.icns $ICONS_DIR/icon.icns
rm -rf icon.iconset

echo "アイコン生成完了: $ICONS_DIR"
```

### リソースファイルの管理

**src-tauri/tauri.conf.json でのリソース設定**

```json
{
    "bundle": {
        "resources": ["resources/*", "assets/database.db", "assets/config/*"],
        "externalBin": ["binaries/helper-tool"]
    }
}
```

**リソースファイルへのアクセス（Rust）**

```rust
use tauri::api::path::resource_dir;

#[tauri::command]
async fn load_bundled_resource(app: tauri::AppHandle, filename: String) -> Result<String, String> {
    let resource_path = app.path().resource_dir()
        .map_err(|e| format!("リソースディレクトリの取得に失敗: {}", e))?
        .join(&filename);

    std::fs::read_to_string(resource_path)
        .map_err(|e| format!("リソースファイルの読み込み失敗: {}", e))
}
```

## 3. プラットフォーム別のビルド

### macOS 向けビルド

**コード署名の設定**

`src-tauri/tauri.sign.conf.json`

```json
{
    "bundle": {
        "macOS": {
            "signingIdentity": "Developer ID Application: Your Name (TEAM_ID)",
            "entitlements": "entitlements.plist"
        }
    }
}
```

**entitlements.plist（アプリケーション権限）**

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
    <key>com.apple.security.app-sandbox</key>
    <true/>
    <key>com.apple.security.files.user-selected.read-write</key>
    <true/>
    <key>com.apple.security.files.downloads.read-write</key>
    <true/>
    <key>com.apple.security.network.client</key>
    <true/>
    <key>com.apple.security.print</key>
    <true/>
</dict>
</plist>
```

**ビルドスクリプト（build-macos.sh）**

```bash
#!/bin/bash

echo "macOS向けビルドを開始..."

# 環境チェック
if ! command -v tauri &> /dev/null; then
    echo "Tauri CLIがインストールされていません"
    exit 1
fi

# 依存関係のインストール
echo "依存関係を更新中..."
npm install

# フロントエンドビルド
echo "フロントエンドをビルド中..."
npm run build:prod

# 署名付きビルド
echo "署名付きでTauriアプリをビルド中..."
tauri build --config src-tauri/tauri.sign.conf.json

# 公証（Notarization）
if [[ -n "$APPLE_ID" && -n "$APPLE_PASSWORD" ]]; then
    echo "アプリケーションを公証中..."

    APP_PATH="src-tauri/target/release/bundle/macos/YourApp.app"
    DMG_PATH="src-tauri/target/release/bundle/dmg/YourApp_1.0.0_x64.dmg"

    # アプリケーションを公証
    xcrun notarytool submit "$DMG_PATH" \
        --apple-id "$APPLE_ID" \
        --password "$APPLE_PASSWORD" \
        --team-id "$TEAM_ID" \
        --wait

    # 公証完了後、アプリにスタンプを押す
    xcrun stapler staple "$APP_PATH"
    xcrun stapler staple "$DMG_PATH"

    echo "公証完了"
else
    echo "公証をスキップ（APPLE_ID と APPLE_PASSWORD が設定されていません）"
fi

echo "ビルド完了！"
echo "出力ファイル:"
echo "- APP: src-tauri/target/release/bundle/macos/"
echo "- DMG: src-tauri/target/release/bundle/dmg/"
```

### Windows 向けビルド

**Windows 設定（tauri.conf.json）**

```json
{
    "bundle": {
        "targets": ["msi", "exe"],
        "windows": {
            "certificateThumbprint": null,
            "digestAlgorithm": "sha256",
            "timestampUrl": "",
            "tsp": false,
            "wix": {
                "language": ["ja-JP", "en-US"],
                "template": "wix-template.wxs"
            }
        }
    }
}
```

**WiX テンプレート（wix-template.wxs）**

```xml
<?xml version="1.0" encoding="utf-8"?>
<Wix xmlns="http://schemas.microsoft.com/wix/2006/wi">
  <Product
    Id="*"
    Name="{{product_name}}"
    Language="1041"
    Version="{{version}}"
    Manufacturer="{{manufacturer}}"
    UpgradeCode="{{upgrade_code}}">

    <Package
      InstallerVersion="450"
      Compressed="yes"
      InstallScope="perMachine" />

    <MajorUpgrade
      DowngradeErrorMessage="新しいバージョンが既にインストールされています。" />

    <MediaTemplate EmbedCab="yes" />

    <Feature
      Id="ProductFeature"
      Title="{{product_name}}"
      Level="1">
      <ComponentGroupRef Id="ProductComponents" />
    </Feature>
  </Product>

  <Fragment>
    <Directory Id="TARGETDIR" Name="SourceDir">
      <Directory Id="ProgramFilesFolder">
        <Directory Id="INSTALLFOLDER" Name="{{product_name}}" />
      </Directory>
    </Directory>
  </Fragment>

  <Fragment>
    <ComponentGroup Id="ProductComponents" Directory="INSTALLFOLDER">
      <Component Id="Path" Guid="{{component_guid}}" Win64="$(var.Win64)">
        <File
          Id="Path"
          Source="{{app_exe_source}}"
          KeyPath="yes" />
      </Component>
    </ComponentGroup>
  </Fragment>
</Wix>
```

## 4. 自動更新システム

### Tauri Updater の設定

**Cargo.toml に依存関係追加**

```toml
[dependencies]
tauri-plugin-updater = "2.0"
```

**main.rs で Updater プラグインを登録**

```rust
use tauri_plugin_updater::UpdaterExt;

#[cfg_attr(mobile, tauri::mobile_entry_point)]
pub fn run() {
    tauri::Builder::default()
        .plugin(tauri_plugin_updater::Builder::new().build())
        .invoke_handler(tauri::generate_handler![check_for_updates])
        .run(tauri::generate_context!())
        .expect("error while running tauri application");
}

#[tauri::command]
async fn check_for_updates(app: tauri::AppHandle) -> Result<bool, String> {
    match app.updater().check().await {
        Ok(update) => {
            if update.is_some() {
                println!("アップデートが利用可能です");
                Ok(true)
            } else {
                println!("最新バージョンです");
                Ok(false)
            }
        }
        Err(e) => {
            eprintln!("アップデートチェック失敗: {}", e);
            Err(e.to_string())
        }
    }
}
```

**tauri.conf.json で Updater 設定**

```json
{
    "updater": {
        "active": true,
        "endpoints": [
            "https://your-server.com/api/updates/{{current_version}}/{{target}}/{{arch}}"
        ],
        "dialog": true,
        "pubkey": "YOUR_PUBLIC_KEY_HERE"
    }
}
```

**フロントエンドでのアップデート処理**

```typescript
import { check } from "@tauri-apps/plugin-updater";
import { relaunch } from "@tauri-apps/plugin-process";

class UpdateManager {
    static async checkForUpdates(): Promise<void> {
        try {
            const update = await check();

            if (update) {
                const shouldUpdate = await this.showUpdateDialog(update);

                if (shouldUpdate) {
                    await this.performUpdate(update);
                }
            } else {
                console.log("アプリケーションは最新版です");
            }
        } catch (error) {
            console.error("アップデートチェック失敗:", error);
        }
    }

    private static async showUpdateDialog(update: any): Promise<boolean> {
        return new Promise((resolve) => {
            const dialog = document.createElement("dialog");
            dialog.innerHTML = `
                <div class="update-dialog">
                    <h3>アップデート利用可能</h3>
                    <p>バージョン ${update.version} が利用可能です。</p>
                    <p>更新内容: ${update.body}</p>
                    <div class="dialog-buttons">
                        <button id="update-later">後で</button>
                        <button id="update-now" class="primary">今すぐ更新</button>
                    </div>
                </div>
            `;

            document.body.appendChild(dialog);
            dialog.showModal();

            dialog
                .querySelector("#update-now")
                ?.addEventListener("click", () => {
                    dialog.close();
                    document.body.removeChild(dialog);
                    resolve(true);
                });

            dialog
                .querySelector("#update-later")
                ?.addEventListener("click", () => {
                    dialog.close();
                    document.body.removeChild(dialog);
                    resolve(false);
                });
        });
    }

    private static async performUpdate(update: any): Promise<void> {
        const progressDialog = this.showProgressDialog();

        try {
            let downloaded = 0;
            let contentLength = 0;

            await update.downloadAndInstall((event: any) => {
                switch (event.event) {
                    case "Started":
                        contentLength = event.data.contentLength || 0;
                        console.log("ダウンロード開始");
                        break;
                    case "Progress":
                        downloaded += event.data.chunkLength;
                        const progress =
                            contentLength > 0
                                ? (downloaded / contentLength) * 100
                                : 0;
                        this.updateProgress(progressDialog, progress);
                        break;
                    case "Finished":
                        console.log("ダウンロード完了");
                        break;
                }
            });

            progressDialog.close();
            await relaunch();
        } catch (error) {
            progressDialog.close();
            console.error("アップデート失敗:", error);
            alert("アップデートに失敗しました。後でもう一度お試しください。");
        }
    }

    private static showProgressDialog(): HTMLDialogElement {
        const dialog = document.createElement("dialog");
        dialog.innerHTML = `
            <div class="progress-dialog">
                <h3>アップデート中...</h3>
                <div class="progress-bar">
                    <div class="progress-fill" style="width: 0%"></div>
                </div>
                <p class="progress-text">0%</p>
            </div>
        `;

        document.body.appendChild(dialog);
        dialog.showModal();
        return dialog;
    }

    private static updateProgress(
        dialog: HTMLDialogElement,
        progress: number
    ): void {
        const fill = dialog.querySelector(".progress-fill") as HTMLElement;
        const text = dialog.querySelector(".progress-text") as HTMLElement;

        if (fill) fill.style.width = `${progress}%`;
        if (text) text.textContent = `${Math.round(progress)}%`;
    }
}

// アプリケーション起動時にアップデートをチェック
document.addEventListener("DOMContentLoaded", () => {
    // 起動から少し待ってからチェック
    setTimeout(() => {
        UpdateManager.checkForUpdates();
    }, 5000);
});
```

## 5. CI/CD パイプライン

### GitHub Actions での自動ビルド

**.github/workflows/build.yml**

```yaml
name: Build and Release

on:
    push:
        tags:
            - "v*"
    pull_request:
        branches: [main]

jobs:
    build:
        strategy:
            matrix:
                platform: [macos-latest, windows-latest, ubuntu-latest]

        runs-on: ${{ matrix.platform }}

        steps:
            - uses: actions/checkout@v4

            - name: Setup Node.js
              uses: actions/setup-node@v4
              with:
                  node-version: "20"
                  cache: "npm"

            - name: Setup Rust
              uses: dtolnay/rust-toolchain@stable

            - name: Cache Rust dependencies
              uses: actions/cache@v4
              with:
                  path: |
                      ~/.cargo/registry
                      ~/.cargo/git
                      src-tauri/target
                  key: ${{ runner.os }}-cargo-${{ hashFiles('**/Cargo.lock') }}

            - name: Install dependencies
              run: npm ci

            - name: Build frontend
              run: npm run build

            - name: Install Tauri CLI
              run: npm install -g @tauri-apps/cli

            - name: Build Tauri app (macOS)
              if: matrix.platform == 'macos-latest'
              run: tauri build
              env:
                  APPLE_CERTIFICATE: ${{ secrets.APPLE_CERTIFICATE }}
                  APPLE_CERTIFICATE_PASSWORD: ${{ secrets.APPLE_CERTIFICATE_PASSWORD }}
                  APPLE_SIGNING_IDENTITY: ${{ secrets.APPLE_SIGNING_IDENTITY }}
                  APPLE_ID: ${{ secrets.APPLE_ID }}
                  APPLE_PASSWORD: ${{ secrets.APPLE_PASSWORD }}
                  APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}

            - name: Build Tauri app (Windows)
              if: matrix.platform == 'windows-latest'
              run: tauri build
              env:
                  WINDOWS_CERTIFICATE: ${{ secrets.WINDOWS_CERTIFICATE }}
                  WINDOWS_CERTIFICATE_PASSWORD: ${{ secrets.WINDOWS_CERTIFICATE_PASSWORD }}

            - name: Build Tauri app (Linux)
              if: matrix.platform == 'ubuntu-latest'
              run: |
                  sudo apt-get update
                  sudo apt-get install -y libgtk-3-dev libwebkit2gtk-4.0-dev libappindicator3-dev librsvg2-dev patchelf
                  tauri build

            - name: Upload artifacts
              uses: actions/upload-artifact@v4
              with:
                  name: ${{ matrix.platform }}-artifacts
                  path: |
                      src-tauri/target/release/bundle/
                  retention-days: 30

    release:
        needs: build
        runs-on: ubuntu-latest
        if: startsWith(github.ref, 'refs/tags/v')

        steps:
            - name: Download all artifacts
              uses: actions/download-artifact@v4

            - name: Create Release
              uses: softprops/action-gh-release@v1
              with:
                  files: |
                      **/*.dmg
                      **/*.app
                      **/*.msi
                      **/*.exe
                      **/*.deb
                      **/*.AppImage
                  draft: false
                  prerelease: false
                  generate_release_notes: true
              env:
                  GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
```

### ビルド後の配布

**配布用スクリプト（distribute.sh）**

```bash
#!/bin/bash

VERSION=$(grep '"version"' src-tauri/tauri.conf.json | sed 's/.*"version": "\(.*\)".*/\1/')
BUILD_DIR="src-tauri/target/release/bundle"
DIST_DIR="dist/v${VERSION}"

echo "配布パッケージを準備中（バージョン: ${VERSION}）..."

# 配布ディレクトリを作成
mkdir -p $DIST_DIR

# macOS
if [ -d "$BUILD_DIR/macos" ]; then
    cp -r "$BUILD_DIR/macos"/*.app "$DIST_DIR/"
    echo "macOS .app ファイルをコピーしました"
fi

if [ -d "$BUILD_DIR/dmg" ]; then
    cp "$BUILD_DIR/dmg"/*.dmg "$DIST_DIR/"
    echo "macOS .dmg ファイルをコピーしました"
fi

# Windows
if [ -d "$BUILD_DIR/msi" ]; then
    cp "$BUILD_DIR/msi"/*.msi "$DIST_DIR/"
    echo "Windows .msi ファイルをコピーしました"
fi

# チェックサムを生成
cd $DIST_DIR
for file in *; do
    if [ -f "$file" ]; then
        shasum -a 256 "$file" > "${file}.sha256"
        echo "チェックサム生成: ${file}.sha256"
    fi
done

echo "配布パッケージの準備完了: $DIST_DIR"
ls -la
```

## 6. アプリケーション設定の永続化

### アプリ終了時の状態保存

```rust
use tauri::{Manager, State};
use serde::{Deserialize, Serialize};
use std::sync::Mutex;

#[derive(Serialize, Deserialize, Clone)]
struct AppState {
    window_size: (u32, u32),
    window_position: (i32, i32),
    user_preferences: UserPreferences,
}

#[derive(Serialize, Deserialize, Clone)]
struct UserPreferences {
    theme: String,
    language: String,
    auto_save: bool,
}

type AppStateType = Mutex<AppState>;

#[tauri::command]
async fn save_app_state(
    app: tauri::AppHandle,
    state: State<'_, AppStateType>
) -> Result<(), String> {
    let app_state = state.lock().unwrap().clone();

    let config_dir = app.path().app_config_dir()
        .map_err(|e| format!("設定ディレクトリの取得失敗: {}", e))?;

    std::fs::create_dir_all(&config_dir)
        .map_err(|e| format!("設定ディレクトリの作成失敗: {}", e))?;

    let config_file = config_dir.join("app_state.json");
    let json = serde_json::to_string_pretty(&app_state)
        .map_err(|e| format!("JSON変換失敗: {}", e))?;

    std::fs::write(config_file, json)
        .map_err(|e| format!("設定ファイル保存失敗: {}", e))?;

    Ok(())
}

#[tauri::command]
async fn load_app_state(app: tauri::AppHandle) -> Result<AppState, String> {
    let config_dir = app.path().app_config_dir()
        .map_err(|e| format!("設定ディレクトリの取得失敗: {}", e))?;

    let config_file = config_dir.join("app_state.json");

    if !config_file.exists() {
        // デフォルト設定を返す
        return Ok(AppState {
            window_size: (1024, 768),
            window_position: (100, 100),
            user_preferences: UserPreferences {
                theme: "light".to_string(),
                language: "ja".to_string(),
                auto_save: true,
            },
        });
    }

    let json = std::fs::read_to_string(config_file)
        .map_err(|e| format!("設定ファイル読み込み失敗: {}", e))?;

    serde_json::from_str(&json)
        .map_err(|e| format!("JSON解析失敗: {}", e))
}

fn main() {
    let initial_state = AppState {
        window_size: (1024, 768),
        window_position: (100, 100),
        user_preferences: UserPreferences {
            theme: "light".to_string(),
            language: "ja".to_string(),
            auto_save: true,
        },
    };

    tauri::Builder::default()
        .manage(AppStateType::new(initial_state))
        .invoke_handler(tauri::generate_handler![save_app_state, load_app_state])
        .setup(|app| {
            // アプリ終了時に自動保存
            let handle = app.handle().clone();
            app.listen_global("tauri://close-requested", move |_| {
                tauri::async_runtime::spawn(async move {
                    let state = handle.state::<AppStateType>();
                    if let Err(e) = save_app_state(handle.clone(), state).await {
                        eprintln!("アプリ状態の保存に失敗: {}", e);
                    }
                });
            });
            Ok(())
        })
        .run(tauri::generate_context!())
        .expect("error while running tauri application");
}
```

## 次のステップ

配布とデプロイメントの手法を理解したら、[11\_パフォーマンスとセキュリティ.md](./11_パフォーマンスとセキュリティ.md) でアプリケーションの最適化とセキュリティ対策を学習しましょう。
