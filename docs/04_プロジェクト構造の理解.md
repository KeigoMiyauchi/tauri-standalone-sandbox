# 04. プロジェクト構造の理解

WPF プロジェクトと Tauri プロジェクトの構造を比較し、どのファイルが何に対応するかを理解します。

## WPF vs Tauri のプロジェクト構造比較

### WPF プロジェクト構造（参考）

```
MyWPFApp/
├── App.xaml              # アプリケーション定義
├── App.xaml.cs           # アプリケーションロジック
├── MainWindow.xaml       # メインウィンドウのUI
├── MainWindow.xaml.cs    # メインウィンドウのロジック
├── MyWPFApp.csproj       # プロジェクトファイル
└── packages.config       # NuGet パッケージ
```

### Tauri プロジェクト構造

```
my-tauri-app/
├── index.html            # メインUIの構造 (MainWindow.xaml に相当)
├── src/
│   ├── main.ts          # フロントエンドロジック (MainWindow.xaml.cs に相当)
│   └── style.css        # スタイルシート (App.xaml の Style に相当)
├── src-tauri/
│   ├── src/
│   │   └── main.rs      # バックエンドロジック (App.xaml.cs + ビジネスロジック)
│   ├── Cargo.toml       # Rust 依存関係 (.csproj に相当)
│   ├── tauri.conf.json  # アプリ設定 (app.config に相当)
│   └── build.rs         # ビルドスクリプト
├── package.json         # Node.js 依存関係・スクリプト
├── tsconfig.json        # TypeScript 設定
└── vite.config.ts       # ビルドツール設定
```

## ファイル別詳細解説

### フロントエンド（UI 層）

#### index.html - メイン UI の構造

WPF の MainWindow.xaml に相当するファイルです。

```html
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <link rel="icon" type="image/svg+xml" href="/vite.svg" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Tauri + Vanilla TS</title>
    </head>
    <body>
        <!-- UIの内容をここに記述 -->
        <div class="container">
            <h1>Welcome to Tauri!</h1>
            <!-- その他のUI要素 -->
        </div>

        <!-- TypeScript ファイルの読み込み -->
        <script type="module" src="/src/main.ts"></script>
    </body>
</html>
```

**WPF との対応:**

```xml
<!-- WPF: MainWindow.xaml -->
<Window x:Class="MyApp.MainWindow">
    <Grid>
        <TextBlock Text="Welcome to WPF!" />
    </Grid>
</Window>
```

#### src/main.ts - フロントエンドロジック

WPF の MainWindow.xaml.cs に相当します。

```typescript
import { invoke } from "@tauri-apps/api/core";

// グローバル変数（WPF のフィールドに相当）
let greetInputEl: HTMLInputElement | null;
let greetMsgEl: HTMLElement | null;

// 関数（WPF のメソッドに相当）
async function greet() {
    if (greetMsgEl && greetInputEl) {
        // バックエンドのRust関数を呼び出し
        greetMsgEl.textContent = await invoke("greet", {
            name: greetInputEl.value,
        });
    }
}

// ページ読み込み完了時の処理（WPF の Loaded イベントに相当）
window.addEventListener("DOMContentLoaded", () => {
    // UI要素の取得
    greetInputEl = document.querySelector("#greet-input");
    greetMsgEl = document.querySelector("#greet-msg");

    // イベントハンドラーの設定
    document.querySelector("#greet-form")?.addEventListener("submit", (e) => {
        e.preventDefault();
        greet();
    });
});
```

**WPF との対応:**

```csharp
// WPF: MainWindow.xaml.cs
public partial class MainWindow : Window
{
    public MainWindow()
    {
        InitializeComponent();
    }

    private void GreetButton_Click(object sender, RoutedEventArgs e)
    {
        // ビジネスロジックの呼び出し
        var result = BusinessLogic.Greet(NameTextBox.Text);
        MessageLabel.Content = result;
    }
}
```

#### src/style.css - スタイルシート

WPF の Style や Template に相当します。

```css
/* 全体のレイアウト */
.container {
    margin: 0;
    padding-top: 10vh;
    display: flex;
    flex-direction: column;
    justify-content: center;
    text-align: center;
}

/* ボタンのスタイル */
button {
    border-radius: 8px;
    border: 1px solid transparent;
    padding: 0.6em 1.2em;
    font-size: 1em;
    font-weight: 500;
    font-family: inherit;
    background-color: #1a1a1a;
    color: white;
    cursor: pointer;
    transition: border-color 0.25s;
}

button:hover {
    border-color: #646cff;
}
```

**WPF との対応:**

```xml
<!-- WPF: App.xaml または Window.Resources -->
<Window.Resources>
    <Style x:Key="MyButtonStyle" TargetType="Button">
        <Setter Property="Background" Value="#1a1a1a" />
        <Setter Property="Foreground" Value="White" />
        <Setter Property="Padding" Value="10,5" />
    </Style>
</Window.Resources>
```

### バックエンド（ビジネスロジック層）

#### src-tauri/src/main.rs - メインプログラム

WPF の App.xaml.cs とビジネスロジッククラスを合わせたような役割です。

```rust
// デバッグビルド時にコンソールウィンドウを表示しない設定
#![cfg_attr(not(debug_assertions), windows_subsystem = "windows")]

// Tauri コマンド（WPF の public メソッドに相当）
#[tauri::command]
fn greet(name: &str) -> String {
    format!("Hello, {}! You've been greeted from Rust!", name)
}

// メイン関数（WPF の Application.Run() に相当）
fn main() {
    tauri::Builder::default()
        .invoke_handler(tauri::generate_handler![greet])  // コマンドの登録
        .run(tauri::generate_context!())
        .expect("error while running tauri application");
}
```

**WPF との対応:**

```csharp
// WPF: App.xaml.cs
public partial class App : Application
{
    protected override void OnStartup(StartupEventArgs e)
    {
        base.OnStartup(e);
        // アプリケーション初期化
    }
}

// ビジネスロジッククラス
public static class BusinessLogic
{
    public static string Greet(string name)
    {
        return $"Hello, {name}! You've been greeted from C#!";
    }
}
```

### 設定ファイル

#### src-tauri/tauri.conf.json - アプリケーション設定

WPF の app.config やプロジェクトプロパティに相当します。

```json
{
    "$schema": "https://schema.tauri.app/config/2",
    "productName": "tauri-app", // アプリケーション名
    "version": "0.1.0", // バージョン
    "identifier": "com.tauri.dev", // 一意識別子
    "build": {
        "beforeDevCommand": "npm run dev", // 開発時の前処理
        "beforeBuildCommand": "npm run build", // ビルド時の前処理
        "devUrl": "http://localhost:1420", // 開発サーバーURL
        "frontendDist": "../dist" // フロントエンドのビルド出力先
    },
    "app": {
        "withGlobalTauri": true,
        "windows": [
            {
                "title": "tauri-app", // ウィンドウタイトル
                "width": 800, // ウィンドウ幅
                "height": 600, // ウィンドウ高さ
                "resizable": true, // リサイズ可能
                "fullscreen": false // フルスクリーン
            }
        ],
        "security": {
            "csp": null // Content Security Policy
        }
    },
    "bundle": {
        "active": true, // バンドル生成の有効化
        "targets": "all", // ターゲットプラットフォーム
        "icon": [
            // アプリケーションアイコン
            "icons/32x32.png",
            "icons/128x128.png",
            "icons/icon.icns",
            "icons/icon.ico"
        ]
    }
}
```

**WPF との対応:**

```xml
<!-- WPF: app.config -->
<configuration>
  <appSettings>
    <add key="AppName" value="MyWPFApp" />
    <add key="Version" value="1.0.0" />
  </appSettings>
</configuration>
```

#### package.json - Node.js プロジェクト設定

WPF の .csproj ファイルに相当します。

```json
{
    "name": "tauri-app",
    "private": true,
    "version": "0.1.0",
    "type": "module",
    "scripts": {
        "dev": "vite", // 開発サーバー起動
        "build": "tsc && vite build", // フロントエンドビルド
        "preview": "vite preview", // プレビューサーバー
        "tauri": "tauri" // Tauri CLI
    },
    "dependencies": {
        // 実行時依存関係
        "@tauri-apps/api": "^2",
        "@tauri-apps/plugin-opener": "^2"
    },
    "devDependencies": {
        // 開発時依存関係
        "@tauri-apps/cli": "^2",
        "typescript": "~5.6.2",
        "vite": "^6.0.3"
    }
}
```

#### src-tauri/Cargo.toml - Rust プロジェクト設定

Rust の依存関係とプロジェクト情報を定義します。

```toml
[package]
name = "tauri-app"
version = "0.1.0"
description = "A Tauri App"
authors = ["you"]
edition = "2021"

[build-dependencies]
tauri-build = { version = "2", features = [] }

[dependencies]
tauri = { version = "2", features = [] }
tauri-plugin-opener = "2"
serde = { version = "1", features = ["derive"] }
serde_json = "1"
```

## 開発ワークフロー

### 1. 開発時（npm run tauri dev）

1. `npm run dev` でフロントエンド開発サーバーが起動
2. Vite が TypeScript をコンパイルし、ホットリロード提供
3. Tauri が Rust コードをコンパイルしてネイティブアプリ起動
4. フロントエンドとバックエンドが IPC で通信

### 2. ビルド時（npm run tauri build）

1. `npm run build` でフロントエンドを `dist/` にビルド
2. Tauri が Rust コードをリリースモードでコンパイル
3. フロントエンドアセットをネイティブアプリに埋め込み
4. OS 固有のインストーラー/パッケージを生成

## 次のステップ

プロジェクト構造を理解したら、[05_HTML による UI 作成の基礎.md](./05_HTMLによるUI作成の基礎.md) で WPF の XAML から HTML への移行方法を学習しましょう。
